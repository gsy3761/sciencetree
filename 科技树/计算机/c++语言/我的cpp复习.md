# c++的复习
- 继承：特殊类的对象拥有一般类的所有属性和服务，那么这个特殊类称为对这个一般类的继承
    - 在程序开发的时候，这个特殊类已经有了这个一般类的全部属性，这个时候我们只需要细致的描述特殊类的特殊属性就可以了。
        - 举一个例子：我们要描述一艘游轮，那么我们只要继承船的一般特性，之后只用描述游轮的特性就可以了
> 继承还是软件的复用，如果将开发好的类作为构件放在构件库中，那么在开发新系统的时候就可以直接使用或继承使用
- 多态性
    - 在一般类中定义的行为后者属性，被特殊类继承之后，表现出不同的行为或属性。这样就可以使同一属性或者行为在一般类和特殊类中拥有不同的语义
        - 举一个例子：我们定义了一个几何图形的类，这个类有一个行为叫做绘图。这时候我们定义一些特殊的类，比如圆形，矩形，这个时候绘图就能够实现绘画出各种形状的功能，这就是面向对象方法中的多态
- 关键字
    - 在c++中的关键字
        - asm,auto（采用堆栈的方式分配内存空间，它的内存空间可以被多次覆盖使用，属于暂时性存储）,bool,break,case,catch,char,class,const,const_cast,continue,default,delete,do,double,dynamic_cast,else,enum,explicit,export,extern（在所有函数和程序段中都可以使用）,false,float,for,friend,goto,if,inline,int,long,mutable,namespace,new,operater,private,protected,public,register（存储在通用寄存器中）,reinterpret_cast,renturn,short,signed,sizeof,static（在内存中是固定地址摆放的，在程序运行的期间全部生效，涉及到变量的作用域和可见性）,static_cast,struct,switch,template,this,throw,true,try,typedef,typeid,typename,union,unsigned,using,virtual,void,volatile,wchar_t,while
- 标识符的命名规则
    - 由大写字母或者小写字母或者下划线作为开始
    - 在cpp中的变量名等等是区别大写字母和小写字母的
    - 变量名等等的命名方式只能由大写字母或者小写字母或者数字0~9或者下划线共同组成
- cpp的书写规范：
    - cpp的书写规范不是非常的严谨，在存在空格的地方都可以使用回车键，举一个例子：
        ```cpp
        int i;
        int
        i
        ;
        ```
> 这两者在cpp中是等价的，在cpp中一个空格与多个空格的意义是一样的，可以看成是一个空格
- cpp预定义的转义序列
    - \a响铃
    - \n换行
    - \t水平制表符
    - \v垂直制表符
    - \b退格
    - \r回车
    - \v换页
- 符号常量
    - 符号常量需要事先进行说明，而且在说明的时候必须进行赋值，赋值之后不能更改。
    - 定义符号变量的规则：
        - const 变量类型说明符 变量名=常量值
        - 下面举一个例子：
            ```
                const float a=5;
            ```
> 注意：在cpp中，逗号，也是一个运算符
```cpp
a=5*20,a*3;//这个时候的输出是300
这种情况先计算表达式1，再计算表达式2，然后输出的是表达式2的值
```
- sizeof 运算符
    - sizeof运算符用于计算某种类型的对象在内存中所占的字节数
    - 语法形式：sizeof（类型名）后者sizeof 表达式
- 条件表达式：
    - 形式：表达式1？表达式2：表达式3
    - 要求：表达式1必须为布尔式，表达式2和3可以随一，也可以是不同形式的式子
    - 当真值为1时候进入表达式2，当真值为0的时候进入表达式3
- 位运算
    - 运算方式：按位与&，按位或|，按位异或^，按位取反~，移位<<或者>>（移的是二进制位）
- 运算符的优先级和结合性
    |优先级|运算符|结合性|
    |-----|-----|-----|
    |1|[ ],( ),.,->,后置++，后置--|左$\to$右|
    |2|前置++，前置--，sizeof，&，*，+（正号），-（负号），~，！|右$\to$左|
    |3|(强制转换类型)|左$\to$右|
    |4|.*,->*|左$\to$右|
    |5|*,/,%|左$\to$右|
    |6|+(加号)，-(减号)|左$\to$右|
    |7|<<,>>|左$\to$右|
    |8|<,>,<=,>=|左$\to$右|
    |9|==,!=|左$\to$右|
    |10|&|左$\to$右|
    |11|^|左$\to$右|
    |12|\||左$\to$右|
    |13|&&|左$\to$右|
    |14|\|\||左$\to$右|
    |15|?:|右$\to$左|
    |16|=,*=,/=,%=,+=,-=,<<=,>>=,&=,^=,\|=|右$\to$左|
    |17|,|左$\to$右|
- 混合运算的时候数据类型的转化
    - 隐含转换
        - 转换的基本原则是把低类型转换为高类型
        - 顺序：$_低\underrightarrow{char\qquad short\qquad int\qquad unsigned\qquad long\qquad unsigned long \qquad float \qquad double}_{高}$
    - 显式转换
        - 类型说明符 （表达式）或者（类型说明符） 表达式
- 数据的输入和输出
    - “<<”是预定义的插入符，作用在流对象cout上就可以完成在屏幕上的最基本的输出
- 在cpp中也是有输出格式控制的
    |操纵符名|含义|
    |---|---|
    |dec|数值数据采用十进制来表示|
    |hex|数值数据采用十六进制表示|
    |oct|数值数据采用八进制表示|
    |ws|提取空白符|
    |endl|插入换行符并且刷新流|
    |ends|插入空字符|
    |setsprecision(int)|设置浮点数的小数位数(包括小数点)|
    |setw(int)|设置域宽|
> 举一个例子：要输出浮点数3.1415并且要换行，设置域宽为5个字符，小数点后保留两位有效数字，输出语句如下：
cout<<setw(5)<<setprecision(3)<<3.1415<<endl;
- 类型声明的语法格式
    - typedef 已有类型名 新类型名表
    - 其中新类型名表中可以有多个标识符，它们之间以逗号分隔
> 例如：typedef double area,Volume
- 枚举类型
    - 枚举类型的声明形式：
    enum 枚举类型名 {变量值列表}；
> 举个例子：enum Weekday {SUM,MON,TUE,WED,THR,FRI,SAT};
- 枚举类型应用说明
    - 对枚举元素按照常量处理，不能给它们赋值
    >SUM=0//这是非法的
    - 枚举元素具有默认值，它们的默认值分别为0，1，2，3······，在这边SUM就是0
    - 也可以在定义枚举类型的时候给枚举类型赋值，那么这时候枚举类型的值根据的是子集赋值给它们时候的值，而不是根据默认值了
    - 枚举值可以进行关系运算
    - 正数值不能直接赋值给枚举变量，如果需要将整数赋值给枚举变量，应该强制类型转换
>在使用枚举类型的时候，可以这样定义枚举类型：
Weekday a;//声明变量
>int a=SUM;//隐含类型转换
>a=Weekday(b);//显式类型转换
- 函数
    - 主函数main是程序执行的开始点，由主函数调用子函数，子函数还可以调用其他的子函数
    - 调用其他函数的函数叫做主调函数，被其他函数调用的函数叫做被调函数。一个函数可能同时具有主调函数和被调函数两个身份
- 函数的定义：
    - 类型说明符 函数名（含类型说明的形式参数表）
    {
        语句序列
    }
    - 含类型说明的形式参数表的内容是这样的：
        - type1 name1，type2 name 2，···，typen namen
        - 其中的type是类型标值符，表示形参的类型。name1，name2，···，namen是形参名
    - 函数的形参列表可以为空，main函数的形参列表大多时候就是空的。main函数也可以右形参，其形参也称为命令行参数，由操作系统在启动程序的时候初始化。不过命令行参数的数量和类型有特殊的要求。
    - 函数的返回值：
        - 函数可以有一个返回值，函数的返回值是许哟啊返回给主调函数的处理结果。类型说明符规定了函数返回值的类型。
            - 格式：return 表达式；
        - 除了指定函数的返回值外，return语句还有一个作用，就是结束当前函数的执行。
        - 一个函数也可以不将任何值返回给主调函数，这时候它的类型标识符为void，所以不写return语句，但是也可以写一个不带表达式的return语句，用于结束当前函数的调用。
            - 格式：return；
- 函数的调用;
    - 如果希望在函数定义之前调用函数，那么首先需要声明这一个函数。
        - 格式：类型说明符 函数名 （含类型说明的形参表）
    - 在声明函数的时候，理论上是可以省略参数名只保留参数类型的，但还是建议保留参数名
    - 声明了函数原型之后，就可以这样子调用子函数：
        - 函数名（实参列表）
            - 实参列表中应该与函数原型中的实际参数的数量要一致
            - 函数调用作为一个语句的时候可以没有返回值，但是函数调用在一个表达式中的时候，必须有一个返回值
> 如何表示一个小数字：
>这里表示$10^{-15}$表示为：1e-15
- 获取随机数字的方法：rand（）；括号里面的是种子数
    - 如果想要随机种子数可以这么做：srand（seed）；这么做就是将种子seed传递给了rand函数，这里的seed是一个数字，可以手动输入
- 函数的嵌套调用：
    - 如果说函数1调用了函数2，函数2调用了函数3，那么形成了函数的嵌套调用。函数是允许嵌套调用的
- 递归调用
    - 函数可以直接或者间接的调用自身，称为函数的递归调用。调用自身就是在一个函数的函数体中出现了对自身的调用表达式
    - 递归问题适合那些新出现的问题是原来问题的简化版本
    - 递归的应用：求阶乘，求排列组合，汉诺塔
        - 关于排列组合的公式：$C^k_n=C_{n-1}^k+C_{n-1}^{k-1}(这里面指的是从n个人中挑选出k个人的可能数）$
        - 汉诺塔就是把第一座塔的前n-1个盘子全部放到第二座塔上，然后把第n个塔放在第三座塔上，然后把第二座塔上的前n-2个盘子放在第一座塔上面，把第n-1个盘子放在第三座塔上。如此往复直到所有的盘子全部在第三座塔上
            - 汉诺塔的最下方的盘子移动到想要的位置最困难，一层的汉诺塔需要进行一次操作，二层的汉诺塔需要进行三次操作，三层的汉诺塔需要进行七次操作。n层的汉诺塔需要进行n-1层汉诺塔操作数量的两倍然后加1。
- 函数的参数传递
    - 在函数没有被调用的时候，函数的形参并不占有函数的实际内存空间，也没有实际的值。只有在函数被调用的时候才会为形参分配内存空间，并且将实参与形参相结合。每个实参都是一个表达式，其类型必须与形参相符合。
    - 函数的参数传递指的就是形参与实参相结合的过程，这种方式有值传递和引用传递
        - 值传递：当函数发生函数调用的时候，给形参分配内存空间，并且用实参来初始化形参。这个过程是参数值单向传递的过程，形参一旦获取了值就和实参脱离了关系。之后无论形参发生了什么样子的变化都不会影响到实参
        - 引用传递：引用传递可以使形参的变换对应到实参的变换。引用是一种特殊的变量，可以被认为是另一变量的别名，通过引用名与通过被引用的变量名访问变量的效果是一样的。
            - 使用引用的时候需要注意的问题：声明一个引用时，必须同时对它进行初始化，使它指向一个已存在的对象。
            - 一旦一个引用被初始化后，就不能改为指向其他的对象。
- 比如自定义的swap函数：
    - void swap（int a，int b）是不能改变实参的，这个是值传递
    - void swap（int &a，int &b）是引用传递，能够改变实参
- 内联函数
    - 引言：使用函数可以提高开发效率，有利于代码重用，但是会降低程序的执行效率，增加时间和空间的开销。
    - 内联函数常常用于规模小使用次数频繁的函数，因为内联函数不是在调用时发生控制转移，而是在编译的时候将函数体嵌入到每一个调用处。这样子节省了参数传递，控制转移的开销
        - 内联函数定义的语法：
            - 只要在原来想要定义的函数的前面加上inline就可以了
            > 示例：inline void swap（int &a，int &b）
            - 注：如果将一些复杂的函数作为内联函数反而会造成开销过大，代码膨胀
            - 现在很多编译器会自动把简单的函数作为内联函数，对于复杂的函数还是当作简单的函数。对自身存在直接递归调用的函数是一定不能内联的。
            - 内联函数的作用是把调用函数的地方用自定义函数的内容全部替换
- 带默认形参值的函数
    - 函数在定义的时候可以预先声明默认的形参值。在调用的时候如果有实参，那么还是拿实参来初始化形参，如果没有实参，那么再使用定义在形参表中的参数。
    - 特别注意：如果一个函数在定义之前有声明，那么形参值需要在声明的时候给出，在定义的时候不能再增加自定义形参值
# 函数重载
- 一个函数就是一个操作的名字。我们生活中的一词多义映射到函数中就是函数的重载
> 举例：擦桌子，擦车子，动作都是擦，但是行为是完全不一样的。但是没有人会说用擦桌子的方法去擦桌子，这样子就形成了函数的重载。
- cpp的重载就是给不同的函数以相同的函数名，编译的时候会根据上下文（形参的数量和形参的类型）来确定调用哪一个函数，这就是函数的重载
- 函数的返回值与函数的重载无关
- 在使用重载函数的时候要避免函数出现二义性。比如由于过多的使用了默认形参值导致的函数二义性
# cpp的系统函数
- 如果想要使用sin（）等等的函数，就要使用头文件cmath
    - 这边特别说一下：弧度=角度$*\pi /180$
    - 因为要对c语言文件兼容，所以在cpp中使用.h结尾的头文件都是可以的。但是我们在编写cpp文件的时候尽量不要使用这些.h为结尾的头文件
# 全局变量与局部变量
- 全局变量：变量的定义全部写在函数以外，生存期是这个程序的运行周期
- 局部变量：变量的定义全部在函数体以内，函数返回一个值以后局部变量就失效了。如果给每一个局部变量不同的内存空间会导致内存的浪费
- 当发生递归调用的时候，同一个变量名会有不同的值，这时候需要给每一个局部变量分配不同的内存空间，也就是要分配不同的内存地址
- 函数的形参和局部变量一样，它们都不能像函数的全局变量一样用固定的地址来定位。它们要存储在一中特殊的结构中，这种结构就是栈。
# 类与对象
- 抽象
    - 对具体问题（对象）进行概括，抽出一类对象的公共性质并加以描述的过程
    - 对一个问题的抽象包括两个方面：数据抽象和行为抽象
- 封装
    - 封装就是将抽象得到的数据和行为（或功能）相结合，形成一个整体。将数据与操作数据的函数结合，形成类，数据和函数都是类的成员
    - 通过封装使一些成员作为外部接口，而将其他的成员隐蔽起来
- 继承
    - 继承可以在一般概念上派生出特殊概念。这样子可以使一般概念的属性和行为能够被特殊类所使用，避免了重复分析和重复开发的困境。继承就是在原有类的基础上，继续更具体更详细的说明
- 多态
    - 多态性是一段程序能够处理多种类型对象的能力。在cpp中，这种多态性可以通过强制多态，重载多态，类型参数化多态，包含多态这四种方式来实现
        - 强制多态：将一种类型的数据强行转换成另一种类型的数据，也就是前面讲到的数据类型转换（隐式和显式）。
        - 包含多态和类型参数化多态属于一般多态性，是真正的多态
        - 包含多态是用虚函数实现的
        - 虚函数是多态的精华，模板是cpp实现参数化多态性的工具，分为函数模板和类模板两种
- 类的对象
    - 类构成了面向对象程序设计中的程序模块
    - 类是对逻辑上相关的函数与数据的封装，是对问题的抽象描述
- 类成员的访问控制
    - 对类成员的访问控制，是通过设置成员的访问控制属性而实现的。访问控制属性有三种：public，private，protected
        - 公有类型定义了类的外部接口，在类外只能访问类的这一个部分的成员
        - 私有类型只能被类内的成员或者函数访问，任何类外对类中的私有成员的访问都是非法的，这样子私有成员完全的隐蔽在类中，保护了数据的安全性
            - 一般情况下类的数据成员都应该声明为私有成员，这样子该类的内部数据结构就不会对类以外的其他部分造成影响，程序之间模块的相互影响就会被降到最低
        - 保护类型和私有类型差不多，只是在继承的时候对新类的影响不同
- 对象
    - 类的对象就是该类的一个特定实体
    - 如果将类看成是自定义的类型，那么类的对象就可以看成是该类型的变量
    - 申明一个对象的方式：类名 对象名
    > 比如clock myclock
    - 对象占据的内存空间只是用于存放数据成员，函数成员不在每一个对象中存储副本，每个函数的代码在内存中只占据一份空间
- 访问类的成员的方法：
    - 调用数据成员名：对象名.数据成员名
    - 调用函数成员：对象名.函数成员名（参数表）
    - 还是要注意在类的外部只能访问到类的外部接口，在类的内部能够访问到类的全部内容
- 类的成员函数
    - 类的成员函数描述的是类的行为，是程序算法的实现部分，也是封装的数据进行操作的方法
        - 成员函数的实现
            - 函数的原型声明要写在类体中。函数原型说明了函数的返回表和返回值类型，
            - 函数的具体实现是卸载类定义之外的。
            - 类的成员函数和普通的函数的不同之处是实现成员函数的时候要指明类的名称
            > 具体形式：返回值类型  类名：：函数成员名（参数表）
            {
                函数体
            }//这边指的是对已经在类中申明的函数进行的函数实现
        - 成员函数调用中的目的对象
            - 调用一个成员函数与调用一个普通函数的差异在于需要使用.操作符指出调用所针对的对象，这个对象在本次调用中称为目的对象。
            > 比如调用：myclock.showtime()；函数，这边的目的对象就是myclock
            - 在成员函数中可以不使用.操作符而直接引用目的对象的数据成员。如果在这个成员函数中不使用.而直接调用成员数据，那么调用的就是本对象中的成员数据。在本对象中的成员函数需要引用其他对象的成员数据或者成员函数的时候，也是需要使用.操作符的
            - 注意：在类的成员函数中，既可以访问本类中的私有成员，也可以访问当前类的其他对象的私有成员
        - 带默认形参值的成员函数
            - 类的成员函数也可以带有默认形参值。它的调用规则和普通函数一致。类成员函数的默认值，一定要写在类的定义（声明）中，而不能写在类定义之外的函数实现中。这样子如果调用这个函数的时候没有给出实参，就会按照默认的形式使用默认形参值
            > 举例：public: void settime(int newh=0,int newm=0,int news=0);
        - 内联成员函数
            - 内联函数的声明方式有两种：隐式申明和显式申明
                - 隐式申明：将函数体放在类体内。也就是说把简单的成员函数的函数体写在了类的定义中（和常规不一样，常规的成员函数的实现是写在类外的），以达到成员函数的隐式申明
                - 显示申明：在成员函数实现的时候，在返回值类型的前面加上inline，在类的定义中不像隐式申明那样出现函数体
                - 隐式申明和显式申明的效果是一样的
```cpp
#include<iostream>
using namespace std;
class clock
{
	public:
		int settime(int newh=0,int newm=0,int news=0);
		void showtime();
	private:
		int hour,minute,s;
};
int main()
{
	clock myclock;
	int a=1,b=1,c=1;
	cout<<"the first time"<<endl;
	myclock.settime();
	myclock.showtime();
	cout<<endl;
	cout<<"the second time"<<endl;
	myclock.settime(1,2,3);
	myclock.showtime();
 } 
int clock::settime(int newh,int newm,int news)
{
	hour=newh;
	minute=newm;
	s=news;
}
void clock::showtime()
{
	cout<<hour<<minute<<s<<endl;
}//自己写的时钟程序，对应上下文碰到的时钟程序
```
- 构造函数和析构函数
    - 类和对象的关系就像是基本数据类型和变量的关系，也就是一般与特殊的关系
    - 对象区别于其他对象的地方：
        - 外在的区别：函数的名称
        - 内在的区别：函数自身的属性，数据成员的值
    - 就像在定义基本类型变量的时候可以同时进行初始化一样，在定义对象的时候，也可以同时对它的数据成员赋初值。
    - 在定义对象的时候进行的数据成员设置，称为对象的初始化
    - 在特定对象使用结束时，还经常需要进行一些清理工作。cpp程序中的初始化和清理工作，分别由两个特殊的成员函数完成，它们就是构造函数和析构函数。
- 构造函数
    - 构造函数的引言
        - 每一个变量在程序运行的时候都要占据一定的内存空间，在申明一个变量的时候对变量进行初始化，这就意味着在变量分配内存单元的同时，在其中写入了变量的初始值
        - 这样子的初始化在cpp程序中看似简单，但是编译器却需要根据变量的类型自动产生一些代码来完成初始化过程
        - 对象也是相似的。但是与普通的变量相比，类的对象太复杂了，编译器不知道如何产生代码以初始化。因此需要对对象初始化的话，需要程序员自己写程序
        - 如果没有自己编写初始化程序，却在声明对象的时候贸然使用指定对象的初始值，不仅不能实现初始化，还会引起编译时候的语法错误。这也是在前面没有对对象进行初始化而是对类的成员函数的值初始化（时钟程序）
    - 构造函数的作用：
        - 在对象被创造的时候利用特定的值构造对象，将对象初始化为一个特定的状态
    - 构造函数也是类的一个成员函数，除了一般成员函数的特征之外还有一些特殊的性质：
        - 构造函数的函数名与类名相同，而且没有返回值
        - 构造函数通常被神明为公有函数。只要类中有了构造函数，编译器就会在建立新对象的地方自动插入对构造函数调用的代码。因此我们通常说构造函数在对象被创建的时候被自动调用。
            - 调用时无需提供参数的构造函数称为默认构造函数。如果类中没有写构造函数，那么编译器会自动生成一个隐含的默认构造函数，该构造函数的参数表和函数体都为空
            - 如果类中申明了构造函数（无论是否有参数），编译器就不再会为对象生成隐含的构造函数
            > 比如在前面的时钟程序中，编译系统会在编译时自动生成一个默认形式的构造函数：clock(){};
            - 这个构造函数clock（）{}；不做任何事。生成这个不做任何事的构造函数是因为在建立对象时自动调用构造函数是cpp程序“例行公事”的必然行为
                - 注意：这边的空的构造函数的确不做事情。但是有时候函数体为空的构造函数并非不做任何事情，因为它还要负责基类的构造和成员对象的构造
            - 如果程序员定义了恰当的构造函数，clock类的对象在建立的时候就能获取一个初始的时间值，以下是改造后的程序：
```cpp
#include<iostream>
using namespace std;
class clock
{
	public:
        clock(int newh,int newm,int news);//新加入的构造函数
		int settime(int newh=0,int newm=0,int news=0);
		void showtime();
	private:
		int hour,minute,s;
};
int main()
{
//	clock myclock;
    clock myclock(0,0,0);//构造函数的作用
	int a=1,b=1,c=1;
	cout<<"the first time"<<endl;
	myclock.settime();
	myclock.showtime();
	cout<<endl;
	cout<<"the second time"<<endl;
	myclock.settime(1,2,3);
	myclock.showtime();
 } 
int clock::settime(int newh,int newm,int news)
{
	hour=newh;
	minute=newm;
	s=news;
}
void clock::showtime()
{
	cout<<hour<<minute<<s<<endl;
}
clock::clock(int newh,int newm,int news)//构造函数的实现
{
    hour=newh;
    minute=newm;
    s=news;
}
```
- 这个时候，在建立对象myclock的时候，会调用构造函数，将实参值用作初始值。这里的自定义的构造函数带有形参，所以建立对象时就必须给出初始值，用来作为调用构造函数时的实参。
- 如果在main函数中这样声明对象：clock c2；编译的时候就会出现语法错误，因为没有给出对应的实参
- 作为类的成员函数，构造函数可以直接访问类的所有数据成员，可以是内联函数，可以带有参数表，可以带默认的形参值，也可以重载。我们可以针对性的选择合适的形式将对象初始化为特定的状态。
    - 构造函数也是可以被重载的。和普通的函数一样，根据函数类型和参数表数量的不同对应使用不同的构造函数。
- 复制构造函数
    - 生成一个对象的副本有两种途径
        1. 建立一个新对象，然后将一个已有对象的数据成员的值一个一个的取出来，一个一个的赋值给新的对象
        2. 使用复制构造函数
    - 复制构造函数是一种特殊的构造函数，具有一般构造函数的所有特性。其形参是本类对象的引用。其作用是使用一个已经存在的对象（由复制构造函数的参数指定），去初始化同类的一个新对象
    - 如果程序员没有自己定义一个复制构造函数，那么编译器会自动生成一个隐含的复制构造函数
        - 这个隐含的复制构造函数的功能是：把初始值对象的每个数据成员的值都复制到新建立的对象中。也可以说完成了同类对象的复制，这样子得到的对象和原对象具有完全相同的数据成员，完全相同的属性。
    - 申明和实现复制构造函数的一般方法：
    ```cpp
    class 类名
    {
        public: 
            类名（形参表）；//构造函数
            类名（类名 &对象名）；//复制构造函数
            ...
    }；
    类名：：类名（类名 &对象名）；//复制构造函数的实现
    {
        函数体
    }
    ```
- 举一个例子：
    ```cpp
    class Point
    {
        public：
            Point(int xx=0,int yy=0)//构造函数
            {
                x=xx;
                y=yy;
            }
            Point (Point &p);//复制构造函数
            int getX{return x};
            int getY{return y};
        private:
            int x,y;
    };
    ```
- 
    - 普通构造函数是在对象创建时被调用，而复制构造函数在以下三种情况下都会被调用
        1. 当用类的一个对象去初始化该类的另一个对象的时候
        ```cpp
        int main()
        {
            Point a(1,2);
            Point b(a);//用对象a初始化对象b，复制构造函数被调用
            Point c=a;//用对象a初始化对象c，复制构造函数被调用
            cout<<b.getX()<<endl;
            return 0;
        }
        ```
    -  注：以上对b和c的初始化都能够调用复制构造函数，两种写法只是形式上有所不同，执行的操作完全相同。
        2. 如果函数的形参是类的对象，调用函数的时候，进行形参和实参的结合，比如：
        ```cpp
        void f (Point p)
        {
            cout<<p.getX()<<endl;
        }
        int main() 
        {
            Point a(1,2);
            f(a);//函数的形参为类的对象，当调用函数的时候，复制构造函数被调用
            return 0；
        }
    - 注：只有把对象用于值传递的时候，才会调用复制构造函数。如果是引用传递，则不会调用复制构造函数。由于这个原因，传递比较大的对象的时候，引用传递比值传递的效率要高
        3. 如果函数的返回值是类的对象，函数执行完成返回调用者时。例如：
        ```cpp
        Point g()
        {
            Point a(1,2);
            return a;//函数的返回值时类对象，返回函数值时，调用复制构造函数
        }
        int main()
        {
            Point b;
            b=g();
            return 0;
        }
        ```
    - 这一小节的完整程序，这个程序会包含三个复制构造函数的三种不同的方法：
        - 
```cpp
#include<iostream>
using namespace std;
class room
{
	public:
		room (int a=0);
		room (room &a);
		int showmoney();
	private:
		int money;
};
void room1 (room &p)//这边的就是单纯的自定义函数了，不在类的里面。这是形参为类的对象的函数 
{
	cout<<p.showmoney()<<endl;
 } 
//room room2()//返回值为类对象的函数 
//{
//	room c(3);
//	return c;
// }//据说现在的编译器优化没有了临时对象 
int main()
{
	room b(1);
	room a(b);
	room1 (a);
	cout<<a.showmoney()<<endl;
//	cout<<room2().showmoney<<endl;//现在的编译器优化没有了临时对象，然后函数中的那个对象又超出了作用范围 
}
room::room(int a)
{
	money=a;
}
room::room(room &a)
{
	money=a.money;
}
int room::showmoney()
{
	return money;//这边需要注意以下，不知道为什么我使用void作为返回值就是不行 
}
```
- 虽然在很多时候使用自己编写的复制构造函数和默认的复制构造函数的情况是一样的。但是要对对象进行有选择有变化的复制的时候，就需要自己写复制构造函数
- 注意：当类的数据成员中有指针类型的时候，默认的复制构造函数是浅复制，会带来数据安全方面的隐患，要实现正确的复制就需要进行手动的深复制
# 析构函数
- 在对象消失以后，需要做好扫尾事宜
- 析构函数与构造函数的作用基本是相反的，它用来完成对象被删除前的一些清理工作
- 析构函数是在对象的生存期即将结束的时候被自动调用的。调用完成之后对象消失，相应的内存空间也就释放了
- 析构函数也是类的一个公有函数成员，它的名称是由类名前面加“~”构成的，没有返回值，构造函数不接受任何参数，但是析构函数可以是虚函数。如果不进行显式说明，系统也会生成一个函数体为空的隐含析构函数
    - 虚构函数的形式：
        - 举例：~clock（）{}
    - 一般来讲，如果希望程序在对象被删除之前的时刻自动（不需要人为进行函数调用）完成某些事情，就可以把它们写进析构函数中
# 类的组合
- 把比较复杂的问题转换成一个一个简单问题的组合，由比较简单的部件对象装配而成
- 类的组合描述的就是一个类内嵌其他类的对象作为成员的情况，它们之间的关系是一种包含与被包含的关系
- 对于稍微复杂一些的类都可以使用组合来描述，这样子复合逐步求精的思维规律
- 当创建类的对象的时候，如果这个类具有内嵌对象成员，那么各个内嵌对象将首先被自动创建。因为部件对象是复杂对象的一部分，因此在创建对象时既要对本类的基本类型数据成员进行初始化，又要对内嵌成员函数进行初始化。
- 组合类构造函数定义的一般形式为：
    - 类名：：类名（形参表）：内嵌对象1（形参表），内嵌对象2（形参表），内嵌对象3（形参表），···{类的初始化}
        - 其中：内嵌对象1（形参表），内嵌对象2（形参表），···称为初始化列表，其作用是对内嵌对象进行初始化
        - 在创建一个组合类的对象时，不仅它自身的构造函数的函数体将被执行，而且还将调用其内嵌对象的构造函数。这时构造函数的调用顺序如下
        1. 调用内嵌对象的构造函数，调用的顺序按照内嵌对象在在组合类的定义中出现的次序。内嵌对象在构造函数的初始化列表中出现的顺序与内嵌对象构造函数的调用顺序无关
        2. 执行本类构造函数的函数体
        > 如构有些内嵌对象没有出现在构造函数的初始化列表中，那么该内嵌对象的默认构造函数将被执行。如果一个类存在内嵌的对象，尽管编译系统自动生成的隐含的默认构造函数体为空，但在执行默认构造函数时，如果声明组合类的对象时没有指定对象的初始值，则默认形式（无形参）的构造函数被调用，这是内联对象的默认形式构造函数也会被调用。隐含的默认构造函数并非声明都不做。
        > 有些数据成员的初始化，必须在构造函数的初始化列表中进行。这些数据成员包括两类，一类是没有默认构造函数的内嵌对象，因为这类对象初始化时必须提供参数，另一类时引用类型的数据成员，因为引用型变量必须在初始化时绑定引用的对象。如果一个类包括者两类成员，那么编译器不能够为这个类提供隐含的默认构造函数，这时必须编写显式的构造函数，并且每个构造函数的初始化列表中至少为者两类数据成员初始化
    - 析构函数的调用执行顺序与构造函数刚好相反
        - 析构函数的函数体被执行完毕后，内嵌对象的析构函数被一一执行，这些内嵌对象的析构函数调用顺序与它们在组合类的定义中出现的次序刚好相反
            - 由于要调用内嵌对象的析构函数，所以有时候隐含的析构函数并非什么也不做
> 假设C类中包含B类的对象b作为成员，C类的复制构造函数形式如下：C::C(C &c1):b(c1.b){···}
> 组合类的构造函数：line::line(point xp1,point xp2):p1(xp1),p2(xp2){}
> 组合类的复制构造函数:line::line(line &l):p1(l.p1),p2(l.p2){}
- 前向引用声明
    - cpp的类往往都是先定义后引用的，但是在处理相对复杂的问题，考虑类的组合的时候，很可能遇到两个类相互引用的情况，这种情况也称为循环依赖
    - 前向引用声明是在引用未定义的类之前，将该类的名字告诉编译器，使编译器知道这是一个类名。这样子在程序使用这个类名的时候，编译器就不会认为是错误，而类的完整定义可以在程序的其他地方。
> 引用声明举例：class B;
- 尽管使用了前向引用声明，但是在提供一个完整的类定义之前，不能定义该类的对象，也不能在内联成员函数中使用该类的对象。
> 注意：当使用前向引用声明的时候，只能使用被声明的符号，而不能设计类的任何细节
# UML图形标识
- UML（unified modeling language统一建模语言）是一种面向对象的建模语言，而不是一种编程语言。这种语言中的符号描述概念，概念间的关系描述为连接符号的线
# 结构体和联合体
- 结构体
    - 结构体是一种特殊形态的类，不同的就是默认的访问权限不一样
- 联合体
    - 在一组数据中，任何两个数据不会同时有效。联合体也是一种特殊形态的类，也可以有自己的数据成员和成员函数，可以有析构函数和构造函数，可以控制访问权限。
    - 但是联合体的全部数据成员共享在同一组内存单元
    - 联合体变量中的成员至多只有一个是有意义的
    - 联合体的限制：
    1. 联合体的各个成员对象，不能有自定义的构造函数，自定义的析构函数和重载的复制赋值运算符。不仅联合体的对象成员不能有这些函数，这些对象成员的对象成员也不能有，以此类推
    2. 联合体不能继承，因而也不支持包含多态
# 位域
- 位域是一种允许将类中的多个数据打包，从而使不同成员可以共享相同的字节的机制
    - 位域的定义方式：数据类型说明符 成员名：位数；
- 注意：只有bool，char，int，enum的成员才可以被定义为位域
- 位域虽然节省了内存空间，但是由于打包和解包的过程中需要耗费额外的操作，所以运行时间有可能会增加
# 用构造函数定义类型转换
- 一个构造函数，只要可以用一个参数调用，那么它就设定了一种从参数类型到这个类类型的类型转换
    - 类型转换的例子：
    cout<<line(point(1),point(4)).getlen()<<endl;
    可以转换为：cout<<line((point)1,(point)4).getlen()<<end;或者cout<<line(static_cast<point>(1)),static_cast<point>(4)).getlen()<<endl;
    - 这里的类型转换操作可以省去，因为默认情况下，类的构造函数所规定的类型转换，允许通过隐含类型转换进行。也就是说可以写成以下的形式：cout<<line(1,4).getlen()<<endl;
# 数据的共享与保护 
- 标识符的作用与与可见性
    - 作用域讨论的是标识符的有效范围，可见性讨论的是标识符是否可以被引用
- 作用域 
    - 一个标识符在程序正文中的有效区域
    - cpp中的标识符的作用域有：
        1. 函数原型作用域，比如函数的参数
        2. 局部作用域（块作用域），从声明处开始，到这个函数的结尾。具有局部作用域的变量也可以叫做局部变量
        3. 类作用域
            - 如果在X的成员函数中没有声明同名的局部作用域标志符，那么在该函数内可以直接访问成员函数m
            - 通过表达式x.m或者X::m。这是程序中访问对象成员函数的最基本的方法
            - 通过`ptr->m`这样的表达式，其中ptr为指向X类的一个对象的指针 
        4. 命名空间作用域
            - 一个大型的程序通常由不同的模块组成，不同的模块可能由不同的人写出来，不同模块中的类和函数之间可能发生重名，这样就会引发错误。然而使用了命名空间，就有了分类。
            - 命名空间的语法格式：
                namespace 命名空间名{
                    命名空间内的各种声明（函数声明，类声明···）
                }
            - 在该命名空间内声明的，不属于前面所述的各个作用域的标识符，都属于该命名命名空间作用域
            - 在命名空间内部可以直接引用，当前命名空间的标识符。如果需要引用其他的命名空间，需要使用下面的语法：
            命名空间::标识符号
            > 举例:namespace a{
                class a1{}
            }
            - 如果需要引用类名a2,需要使用下面的方式
                - a:a1 obj1;//声明一个a:a1型的对象obj
            - 有时候因为每次都要加入所在的命名空间的名字,所以在cpp中可以使用using
                - using有两种使用方法:(等待补充,namespace的类似于typedef泛型编程的地方)
                    1. using 命名空间名::标识符名
                        - 将指定的标识符暴露在当前的作用域内,使得在当前作用域中可以直接引用该标识符
                    2. using namespace 命名空间名
                        - 将指定命名空间内的所有标识符暴露在当前的作用域内,使得在当前作用域中可以直接引用该命名空间的任何标识符                    
                - 命名空间是允许嵌套的，那么这时候在引用命名空间中的命名空间中的成员函数的时候的形式是：
                    - 命名空间1：：命名空间2：某成员函数
            - 此外，还有两类特殊的命名空间：
                - 全局命名空间
                    - 全局命名空间是默认的命名空间，在显式声明的命名空间之外声明的标识符都在一个全局命名空间中
                - 匿名命名空间
                    - 匿名空间是一个需要显式声明的没有名字的命名空间
                    - 申明形式：namespace {
                        匿名命名空间内的各种声明（函数声明，类声明···）
                    }
                    - 在包含多个源文件的工程中，匿名命名空间常常被用来屏蔽不希望暴露给其他源文件的标识符。这是因为每个源文件的匿名命名空间是彼此不同的，在一个个源文件中没有办法访问其他源文件的匿名命名空间
                - 具有命名空间的作用域的变量成为全局变量
# 可见性
- 程序运行到某一点，能够引用到的标识符，就是该处可见的标识符
    - 命名空间作用域大于类作用域大于局部作用域  
- 作用域可见性的一般规律如下：
    - 标识符要声明在前，引用在后
    - 在同一作用域中，不能声明同名的标识符
    - 在没有互相包含关系的不同的作用域中声明的同名标识符，互不影响
    - 如果两个或多个具有包含关系的作用域中声明了同名标识符，则外层标识符在内层不可见
- 对象的生存期
    - 从对象的诞生到消失就是对象的整个生存期
    - 静态生存期
        - 如果对象的生存期与程序的运行期相同，那么称它具有静态生存期。在命名空间中声明的对象都是具有静态生存期的
        - 如果要在函数内部的局部作用域中声明具有静态生存期的对象，则要使用关键字static
        > 例如：下列语句定义的变量i便是具有静态生存期的变量，也称为静态变量：static int i=1；
        - 局部作用域中静态变量的特点是它并不会随着每次函数调用而产生一个副本，也不会随着函数返回而失效。也就是说当一个函数返回后，下一次再调用的时候，该变量还会保持上一回的值，即使发生了递归调用，也不会为该变量建立新的副本，该变量会在每次调用期间共享
        - 定义时未指定初值的基本类型静态生存期变量，会被赋予0值初始化，而对于动态生存期变量，不指定初值意味着初值不确定
- 动态生存期
    - 在局部作用域中声明的具有的动态生存期的对象，习惯上也称为局部生存期对象。局部生存期对象诞生于声明点，结束于声明所在的块执行完毕之时。
- 类的静态成员
    - 两种传递方式：参数传递和全局变量
    - 静态数据成员
        - 类属性是描述类的所有对象共同特征的一个数据项，对于任何对象实例，它的属性值是相同的
        - 静态数据成员具有静态生存期。由于静态数据成员不属于任何一个对象，因此可以通过类名对他进行访问。一般的用法是
        > 类名：：标识符
        - 在类的定义中仅仅对静态数据成员进行引用性声明，必须在命名空间作用域的某个地方使用类名限定定义行声明，这时也可以进行初始化
        - 之所以类的静态数据成员需要在类定义之外再加以定义，是因为需要以这种方式专门为它们分配空间。非静态数据成员无需以此方式定义，因为他们的空间是与他们对象的空间同时分配的
        - 对静态成员函数的调用可以通过类名也可以通过对象名进行调用，但是对于普通成员函数的调用必须通过对象名
        - 虽然静态成员函数也可以直接通过对象来调用，因为即使通过对象名调用，起作用的也只是对象的类型信息，与所使用的具体对象毫无关联
        - 静态成员函数可以直接访问该类的静态数据和函数成员，而访问非静态成员，必须通过对象名
# 类的友元
- 友元关系提供了不同类或对象的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制
- 友元函数就是一个类主动声明哪些其他类或函数是它的朋友，然后给他们提供在本类中的访问特许。通过友元关系，一个函数或者类的成员函数可以访问封装于另外一个类中的数据
    - 从某个角度讲，友元函数是对封装数据的隐藏的一种破坏。只要掌握好度就可以。
    - 如果声明一个友元是一个函数，那么就叫做友元函数；如果友元是一个类，那么就叫做友元类。友元类中的所有函数都默认成为友元函数
# 友元函数
- 友元函数是在类中用关键字friend修饰的非成员函数
- 友元函数可以是一个普通的函数，也可以是其他类的成员函数，虽然它不是本类的成员函数，但是在它的函数体中可以通过对象名访问类的私有和保护成员
# 友元类
- 和友元函数一样，一个类可以将另一个类声明为友元类。若A类为B类的友元类，则A类的所有成员函数都是B类的友元函数，都可以访问B类的私有和保护成员
    - 声明友元类的语法形式为：
        - class B{
            ...
            friend class A;//声明A为B的友元类
            ...
        }
    - 关于友元需要注意的:
        1. 友元关系是不能传递的
        > B是A的友元,C是B的友元,但是如果A和C之间没有友元声明,那么A和C不是友元关系
        2. 友元关系是单向的
        > 如果声明了B是A的友元,那么B可以调用A的东西,但是A不可以调用B的东西
        3. 友元关系是不被继承的
        > 如果B是A的友元,类B的派生类并不会自动成为类A的友元
        > 就好像别人信任你,但是不信任你的孩子
# 共享数据的保护
- 对于既需要共享又需要防止改变的数据应该声明为常量,因为常量在程序运行期间是不可以被改变的,所以可以有效的保护数据
- 常对象
    - 它的数据成员值在对象的整个生存期间内不能被改变
    - 常对象必须进行初始化,而且不能被更新
        - 声明常对象的语法形式为:const 类型说明符 对象名;
        > 在声明常对象的时候,把const关键字放在类型后面也是允许的,不过按照习惯还是把const写在前面
        - 例子:
            - class A{
                public:
                    A(int i,int j):x(i),y(j){}
                    ...
                private:    
                    int x,y;
            };
            const A a(3,4);//a是常对象,不能被更新,它的值是不能被改变的
        - 在定义一个变量或常量的时候为它指定的初值叫做初始化,而在定义一个变量或常量以后用赋值运算符修改它的值叫做赋值。要弄清初始化和赋值的不同
    - 语法类类型的常对象的值不被改变：
    1. 将长对象的数据成员全部视为常量
    2. 规定不能通过常对象调用普通的成员函数
# 用const修饰的类成员
- 常成员函数
    - 使用const关键字修饰的函数成为常成员函数，常成员函数声明的格式如下：
        - 类型说明符 函数名（参数表）const
        > 注意:
        1. const是函数类型的一个组成部分,因此在函数的定义部分也要带有const关键字
        2. 如果将一个对象说明为常对象,则通过该常对象只能调用它的常成员函数,而不能调用其他成员函数,而不能调用其他成员函数(这就是c++从语法机制上对常对象的保护,也是常对象唯一的对外的接口方式)
        3. 无论是否通过常对象调用常成员函数,在常成员函数调用期间,目的对象都被视为常对象,因此常成员函数不能更新目的对象的数据成员,也不能针对目的对象调用该类中没有用const修饰的成员函数（这就保证了在常成员函数中不会更改目的对象的数据成员的值）
        4. const关键字可以用于对重载函数的区分。
        > 例如:void print();void print()const;这是对print的有效重载
        > 在使用的时候:
        声明:class R{
            public:
                R(int i,int j)；
            private：
                const int i，j；
        }
        R：：R(int i,int j):i(i),j(j){}
        调用:R a(4,5);//这种方法叫做初始化列表
        这样子不需要再定义R的赋值,会把4赋值给i,把5赋值给j。使用这个：i（i）是因为无法写出i=i这种用法，i=i是语法错误的
        - 对于无需改变成员数据状态的成员，都应该使用const修饰
# 常数据成员
- 类的成员数据也可以是常量，使用const说明即可
    - 构造函数对常数据进行初始化，只能通过初始化列表。常数据只能通过初始化列表的方法来初始化数据
    > 细节:类成员中的静态成员和常量都应该在类定义以外加以定义,但是cpp的标准规定了一个例外:类的静态变量如果具有整数类型或枚举类型,那么可以直接在定义中为它指定常量值:static const int a=10;这时,不必在类定义外定义A::a。但是如果涉及到了取地址，还是需要进行A：：a的
# 常引用
- 如果在声明的时候使用const修饰，被声明的引用就是常引用。
    - 常引用所引用的对象不能被更新
    - 如果常引用做形参，那么不会意外的发生对实参的更改。
- 常引用的声明形式：
    - const 类型说明符 &引用名；
    - 非const的引用只能绑定到普通的对象，不能绑定到常对象。常引用是能够绑定到常对象的。
        - 一个常引用，无论是绑定到一个普通的对象，还是常对象，通过该引用访问该对象时，都只能把该对象当作常对象。
        - 传值的方式比普通引用的方式使用的时间和空间都要大
# 多文件结构和编译预处理命令
- cpp程序的一般组值结构
    - 每个源程序文件称为一个编译单元
    - cpp语法要求一个类的定义必须出现在所有使用该类的编译单元中。惯用的做法是将类的定义写在头文件中，使用该类的编译单元则使用这个头文件。
- 通常一个项目至少划分为3个文件：
    1. 类定义文件(.h文件)
    2. 类实现文件(.cpp文件)
    3. 类的使用文件(.cpp主函数文件)
- 对于更加复杂的类,每个类都有自己的定义文件和实现文件,使用这种方式可以对单个文件进行单独的编写,编译,然后再连接。
- 只要在.cpp主函数文件中包含.h文件就可以了
    - 包含的语法格式为:#include "xxx.h"
    - 一般将不需要使用空间的东西比如类的声明放在头文件中,把需要使用空间的东西放在源文件中比如类的定义,命名空间中变量的定义。内联函数应该在每一个编译单元中都可见
    > 如果误将分配了空间的定义写入头文件中,在多个源文件包含该头文件时,会导致空间在不同的编译单元中被分配多次,从而在连接时发生错误
# 外部变量和外部函数
- 外部变量
    - 如果一个文件除了在定义它的源文件中可以使用外,还能被其他文件使用,那么就称这个变量为外部变量
    - 命名空间作用域中定义的变量默认情况下都是外部变量,但在其他文件中如果需要使用这一变量,需要用extern关键字加以声明
        - 如果存在多个源文件,那么在源文件中需要加入extern int i;//声明一个在其他文件中定义的外部变量i
        - //虽然i定义在另一个文件中,但是由于在需要使用的源文件中使用了extern关键字声明了,因此同样可以使用它.外部变量是可以为多个源文件所共享的全部变量
    - 对外部变量的声明可以是定义性声明,就是声明的同时进行定义(分配内存,初始化),也可以是引用性声明(引用在别处定义的变量)
    - 在命名空间的作用域中,不用extern关键字声明的变量,都是定义性声明。
    - 用extern关键字声明的变量，如果同时指定了初值，则是定义性声明，否则是引用性声明
- 外部函数
    - 在所有类之外声明的函数（也就是非成员函数），都是具有命名空间作用域的。如果没有特殊说明，这样的函数都可以在不同的编译单元中被调用，只要在调用之前进行引用性声明（即声明函数原型）即可。
        - 也可以在声明函数原型或定义函数时用extern修饰，其效果与不加修饰的默认状态是一样的
        > 通常情况下,变量和函数的定义都放在源文件中,而对外部变量和外部函数的引用性声明则放在头文件里
- 将变量和函数限制在编译单元内
    - 在命名空间作用域中声明的变量和函数,在默认情况下都可以被其他编译单元访问
    - 处于数据安全性考虑,不希望一个源文件中定义的命名空间作用域的变量和函数被其他源文件引用
        - 曾经的解决方法:在定义这些变量和函数的时候使用static关键字.static关键字用来修饰命名空间作用域的变量或函数的时候,和extern关键字起相反的作用.它会使得被static修饰的变量和函数无法被其他编译单元引用
        - 凡是被static修饰的变量,都具有静态生存期(不管未使用static关键字的时候它们的生存期如何)
        + 现在的方法:使用匿名的命名空间
            - 在匿名命名空间中定义的变量和函数,都不会暴露在其他的编译单元中
            - 把不希望被其他编译单元引用的函数和变量放在匿名的命名空间中
            > 举例:
            ```cpp
            namespace{
                ···
            } 
            ```
- 标准cpp库
    - cpp的库中继续保留了大部分c语言的系统函数外,还加入了预定义的模板和类
    - 标准cpp库是一个极为灵活并可拓展的可重用软件模块的集合
    - 标准cpp类与组件在逻辑上分为下面6类
        1. 输入输出类
        2. 容器类与ADT(抽象数据类型)
        3. 存储管理类
        4. 算法
        5. 错误处理
        6. 运行环境支持
    - 对库中预定义内容的声明分别存在于不同的头文件中,要使用这些预定义的成分,就要将相应的头文件包含到源程序中.当包含了必要的头文件后,就可以使用其中预定义的内容了
        > 包含这些头文件的目的是在当前编译单元中引用所需的引用性声明,而它们的定义则以目标代码的形式存放于系统的运行库中
    - 在使用命名空间中的东西的时候,可以使用两种方法,比如:
        1. using namespace std;
        2. std::cout
    > 通常情况下,using namespace语句不易放在头文件中,因为这会使一个命名空间不被察觉的对一个源文件开放
# 编译预处理
- 在编译器对源程序进行编译之前,首先要由预处理器对程序进行预处理.预处理器提供了一组编译预处理指令和预操作操作符.预处理指令实际上不是cpp语言的一部分,它只是用来扩充cpp程序设计的环境.所有的预处理指令都是以#来引导,每一条预处理指令单独占一行,不要用分号结束.预处理指令可以根据需要出现在程序的任何位置
1. #include指令
- #include指令也称文件包含指令,其作用是将另一个源文件嵌入到当前源文件中该点处
    - 通常使用#include指令来嵌入头文件,文件包含指令有两种格式:
        1. #include<文件名>
            - 按照标准方式搜索,文件位于系统目录的include子目录下
        2. #include"文件名"
            - 首先在当前目录中搜索,若没有,再按照标准方式搜索
    - #include指令可以嵌套使用
2. #define和#undef指令
    - 预处理器最初是c语言设计的
    - cpp中也可以像在c语言中用#define PI 3.14来定义符号变量,但是对于cpp来说更好的方法是在类型说明语句中用const进行修饰
    - 用#define还可以定义空符号,比如:
        > #define a
        - 定义它的目的,标识a已经被定义过这样一种状态.将该符号配合条件编译指令一起使用,可以起到一些特殊作用
    - #undef的作用是删除由#define定义的宏,使之不再起作用
3. 条件编译指令
    - 使用条件编译指令,可以限定程序中的某些内容要在满足一定条件的情况下才参与编译.
    - 因此使用条件编译可以使同一个源程序在不同的编译条件下产生不同的目标代码.比如可以在调试程序的时候增加一些调试语句,以达到跟踪的目的,并利用条件编译指令,限定当程序调试好后,重新编译时,使调试语句不参与编译
        - 常用的条件编译的方式:
            1. #if 常量表达式
                程序段1  //当常量表达式不是0的时候编译这个程序段
                #else 
                程序段2
                #endif  //当常量表达式是0的时候编译这个程序段
            2. #if 常量表达式
                程序段1   //当常量表达式不是0的时候编译这个程序段
                #endif 
            3. #if 常量表达式1
                程序段1 //当常量表达式1不是0的时候编译这一段
                #elif 常量表达式2
                程序段2  //当常量表达式1为0的时候,常量表达式2不是0的时候进行编译
                #elif 常量表达式n
                程序段n  //当常量表达式1,常量表达式2,常量表达式n-1都是0的时候,常量表达式n不是0的时候编译这个程序段
                #else
                程序段n+1  //其他情况下编译这个程序段
                #endif
            4. #ifndef 标识符  //如果标识符被#define定义过,且未经undef删除,那么编译程序段1
                程序段1
                #else
                程序段2       //否则编译程序段2,如果没有程序段2,那么#else可以省略,但是#endif还是需要保留的
                #endif
            5. #ifndef 标识符   //如果标识符被#define定义过,且未经undef删除,那么编译程序段1,否则编译程序段2,如果没有程序段2,那么#else可以省略
                程序段1
                #else
                程序段2
                #endif
- #define操作符
    - define是一个预处理操作符,而不是指令,因此不要以#开头
    - define操作符使用的形式为:
        - defined(标识符)
        - 若标识符在此前经#defined定义过,而且未经过#undef删除,则上述表达式非0,否则上述表达式的值为0.
    - 以下两种情况是等价的:
        - #ifndef a
        - if!defined(a)
    > 由于文件包含指令可以嵌套使用,在设计程序的时候要避免多次重复包含同一个文件,否则会引起变量以及类的重复定义
    - 为了避免一个文件被多次包含后的编译语法错误,这就要在可能被重复包含的头文件中使用条件编译指令.用一个唯一的标识符来表机某文件是否已经参加过编译,如果已经参加过编译,则说明该程序段是被重复包含的,编译的时候忽略重复的部分,
        - 所以一个头文件中的写法可以如下:
            - #ifndef head_h
              #define head_h
              ···
              #endif
            - 在这个头文件中,首先判断标识符head_h是否被定义过,如果没有定义过,说明这个头文件没有参加过编译,于是编译下面的程序段,并且对标识符head_h进行宏定义,标志这个头文件已经参加过编译.如果标识符head_h被定义过,说明此头文件参加过编译,于是编译器忽略下面的程序段.这样子就不会造成类的重复定义
- 一个新的关键字
    - mutable
    - 使用mutable修饰一类数据成员,这样,即使在常成员函数中,也可以修改它们的值
    - mutable不只允许在常成员函数中修改被它修饰的数据成员
    - "常对象的成员对象被视为常对象"这个语言原则对于mutable修饰的成员对象是不适用的.
    - 被mutable修饰的成员对象在任何时候都不会被视为常对象
    - mutable不可以滥用,否则就会破坏const形成的语言保护机制.
    - 一定确定存在需要改变一个成员对象的常成员函数,而且对该成员函数的调用确实不会改变对象状态,只有保证了这些,mutable才不会被滥用
# 代码的编译链接与执行过程
- 编译
    - 一个源文件,经过编译系统的处理,生成的目标文件的过程叫做编译.编译是对一个个源文件分别处理的,因此每个源文件构成了一个独立的编译单元,编译过程中不同的编译单元互不影响。源文件.cpp经过编译之后,会生成.o的目标文件
    - 目标文件主要用来描述程序在运行过程中需要放在内存中的内容,这些内容包括两大类-----代码和数据.相应的,目标文件也分成代码段和数据段
        - 代码段(.text)中的内容就是源文件中定义的一个个函数编译后得到的有些目标代码目标文件.o的代码中应当包含main函数的目标代码,有些.o代码应当包含函数的代码
            - 无论是普通函数代码,还是类的成员函数代码,都放在代码段中
        - 数据段中包含对源文件中定义的各个静态生存期对象(包括基本类型变量)的描述.数据段又分初始化的数据段(.data)和未初始化的数据段(.bss)其中初始化的数据段中包含了那些在定义的同时设定了初值的静态生存期对象(通过执行静态生存期的方式赋初值的不在此列).对于这些对象,其初值被放在初始化的数据段中.这些对象在运行时占多少内存空间,在目标文件中就要提供多少空间存放他们的初值.
        - 其他静态生存期对象,都放在未初始化的数据段中.由于它们没有静态的初值,目标文件中不需要保留专门空间存储它们的信息,只需要记录这个段的大小
- 连接
    - 在连接期间，需要将各个编译单元的目标文件和运行库当中被调用过的单元加以合并。
    - 运行库实际上就是一个个目标文件的集合，运行库的各个组成部分和目标代码具有相同的结构，     
    - 与此同时，各个目标文件的符号表也可以被综合起来，符号表的每个条目都会由确定的地址。重定位信息这是也能发挥作用了，各段代码中未定义的地址，都可以被替换为有效地址
    - 任何一个对象或函数，引用性声明可以有多个，但是定义性声明有且只能有一个
    - 链接的对象除了用户源程序生成的目标文件外，还有系统的运行库
    - 链接后生成的可执行文件的主体，和目标文件一样，也是各个段的信息，只是可执行文件的代码段中所有指令的地址，都是有效地址了。符号表可以出现在可执行文件中，也可以不出现，这不会影响到程序的执行，如果可执行文件中出现了符号表，也只是对测试工具有用
- 执行
    - 程序的执行是以进程为单位的。程序的一次动态执行称为一个进程。
    - 进程与程序的关系，就像是一次具体的函数调用与函数的关系，程序只有在执行的时候才会生成进程，执行后进程就会消失
    - 程序是存储在磁盘上的，在执行期间，操作系用需要首先将它载入到内存中，被为它分配足够大的内存空间来容纳代码段和数据段，然后把文件中存放的代码段和初始化的数据段的内容载入其中--一部分静态生存期对象的初始化就是通过这种方式完成的，这与动态生存期对象的初始化不同，初始化在操作系统载入初始化的数据段的时候就已经完成了，而在局部作用域中，初始化需要等到执行到这条语句的时候，由编译器生成的代码来完成
    > 那些需要用构造函数来初始化的静态生存期对象又所有不同，他们的初始化需要由编译器生成专门的代码来调用构造函数，这些代码被调用的时机也由编译器控制。命名空间作用域中的此类对象的初始化代码，一般在执行main函数之前，由引导代码调用；局部作用域中的此类对象，其初始化代码一般会内嵌在函数体中，并用一些静态的标志变量来表示这样的对象是否已经初始化，从而保证他们的初始化代码只被执行一次
    - 操作系用还要做一些进程的初始化工作，让这些工作完成之后，就会跳转到程序的引导代码，开始执行程序。当程序执行结束后，引导代码会通知操作系统，操作系统会完成一些善后工作，程序的一个执行周期就这样结束了。
# 总结
- 数据的共享与保护机制是一个很重要的特性，其包含的内容主要为标识符的作用域，可见性和生存期，通过类的静态成员实现同一个类的不同对象之间的数据和操作的共享，通过常成员来设置成员的保护属性
- 程序的多文件结构有助于编写多个源代码文件来组织大型程序。另外通过编译预处理命令可以为源程序做必要的预处理工作，从而可以避免很多不必要的麻烦和错误。
# 数组，指针与字符串
- cpp可以通过使用地址来访问内存，指针变量就是实现这一个功能的有效形式
## 数组
- 数组是具有一定顺序关系的若干对象的集合体，组成数组的对象称为数组的元素
    - 数组有n和下标称为n维数组
- 数组的声明和使用
    - 
    1. 确定数组的名称
    2. 确定数组元素的类型
    3. 确定数组的结构,包括数组维数,每一维的大小
- 数组类型声明的一般形式:
    - 数据类型 标识符 [常量表达式1][常量表达式2]···
- 数组的使用
    - 使用数组的时候，只能分别对数组的各个元素进行操作，数组的元素是由下标来区分的。
        - 对于一个声明过的数组，使用的形式：
            - 数组名 [下标表达式1][下标表达式2]···
- 数组的存储与初始化
    - 数组元素在内存中是顺序,连续存储的
    - 数组的初始化就是在声明数组的时候给部分或者全部的元素赋初值
    - 多维数组可以按照第一维的下标进行分组,使用花括号将每一组数组括起来
    - 数组也可以被声明为常量
- 数组作为函数参数
    - 数组元素和数组名都可以作为函数的参数以实现数据的传递和共享
    - 可以使用数组元素作为调用函数的实参,这与使用该类型的一个变量(或对象)作实参是完全相同的
    - 如果使用数组名作为函数的参数,那么实参和形参都应该是数组名,并且类型要相同.
    - 和普通变量做参数不同,使用数组名传递数据的时候,传递的是地址.形参数组和实参数组的首地址重合,后面的元素按照各自在内存中的存储顺序进行对应,对应的元素使用相同的存储地址,因此实参数组的元素个数不应该少于形参数组的元素个数.如果在被调函数中对形参数组元素值进行改变,主调函数中实参数组的相应元素值也会改变.
    - 对于数组来说:在子函数中对形参元素的操作结果直接影响到函数实参的相应元素
    > 把数组作为参数的时候,一般不指定数组第一维的大小即使指定,也会被忽略
- 对象数组
    - 数组的元素不仅可以是基本的数据类型,也可以是自定义类型.
    - 声明一个一维的对象数组的语句形式是:
        - 类名 数组名 [常量表达式];
            - 与基本类型数组一样,在使用对象数组的时候只能引用单个数组元素,每个数组都是一个元素,通过这一个元素,可以访问到这些对象的公有部分
                - 一般来说访问这些对象的访问形式:
                    - 数组名[下表表达式].成员名
                - 对这些对象数组进行初始化使用的就是它们的构造函数
# 指针
- 指针是一种较为直接的地址操作手段,动态内存分配和管理也离不开指针
- 内存空间的访问方式
    - 利用数据单元存储数据的方式:
        1. 通过变量名
        2. 通过地址
- 指针变量的声明
    - 指针也是一种数据结构,具有指针类型的变量称为指针变量
    - 指针变量是用于存放内存单元地址的
    - 通过变量名访问一个变量是直接的,而通过指针访问一个变量时简介的
        - 指针是先声明再使用的,声明的语法形式是:
            - 数据类型 *标识符;
            > 其中*标识这里声明的是一个指针类型的变量.数据类型可以是任意类型,指的是指针所指向的对象(包括变量和类的对象)的类型,这说明了指针所指的内存单元可以用于存放声明类型的数据,称为指针的类型.
                > 例如:int *ptr;
                > 定义了一个指向int型数据的指针变量,这个指针的名称是ptr,专门用来存放int型数据的地址
- 与地址相关的运算:*和&
    - *称为指针运算符,也称解析,表示获取指针指向的变量的值,是一个一元运算符
    > 例如:*ptr表示指针ptr指向的数据的值
    - &称为取地址运算符,用来的得到一个对象的地址
    > 例如:&i得到存储变量i的存储单元地址
- *与&出现在不同的位置的时候的不同意义
    - 当*出现在声明语句中,在被声明的变量名之前,表示声明的是指针
    > int *p;//声明p是一个int类型的指针
    - 当*出现在执行语句中或声明语句的初始化表达式中作为一元运算符时,表示访问指针所指对象的内容
    > cout<<*p;//输出指针p所指向的内容
    - &出现在变量声明语句中位于被声明的变量的左边时,表示声明的是引用
    > int &rf;//声明一个int型的引用rf
    - &在给变量赋初值时出现在等号右边或在执行语句中作为一元运算符出现的时候,表示取对象的地址
    > int a,b;
    int *pa,*pb=&b;
    pa=&a;
- 指针的赋值
    - 定义一个指针,得到了一个用于存储地址的指针变量,但是变量中并没有确定的值,其中的地址的值是一个不确定的数.也就是说,不能确定这时候的指针变量中存放的是哪个内存单元的地址.这时候指针所指的内存单元中有可能存放着重要数据或者程序代码,如果盲目访问,可能会破坏数据或造成系统故障,这就是野指针的危害
    - 一次定义指针之后必须先赋值,然后才可以引用
        - 对指针赋初值有两种方法:
        1. 在定义指针的同时进行初始化赋值:
        > 存储类型 数据类型 *指针名=初始地址;
        2. 在定义之后,单独使用赋值语句:
        > 指针名=地址;
    - 如果使用对象地址作为指针的初值,或在赋值语句中将对象地址赋值给指针变量,该对象必须在赋值之前就声明过,而且这个对象的类型应该和指针类型一致,也可以使用一个已经赋值的指针取初始化另一个指针.也就是说,可以多个指针指向同一个变量
    - 一个数组,可以用它的名称来直接表示它的起始地址,数组名称实际上就是一个不能被赋值的指针,即指针常量
- 关于指针的类型:
    1. 可以声明指向常量的指针,此时不能通过指针来改变所指向对象的值,但指针本身可以改变,指针可以指向另外的对象.使用指向常量的指针,可以确保指针所指向的常量不被意外更改.如果用一般指针存放常量的地址,编译器就不能确保指针所指的对象不被更改
    > const int* p1=&a;
      p1=&b;
    2. 可以声明指针类型的常量,这时指针本身的值不能被改变
    > int * const p2=&a;(事实上*是一个变量修饰符,理应和数据类型和变量名都有一个空格,但是和任意一边连接在一起也没有问题)
    p2=&b;//这么写是错误的,因为p2是指针常量,值不能改变
    3. 一般情况下,指针的值只能赋给相同类型的指针.但是有一种特殊的void类型指针,可以存储任何类型的对象地址,就是说任何类型的指针都可以赋值给void类型的指针变量.经过适用类型显示转换,通过void类型的指针便可以访问任何类型的数据.
    > 可以定义void类型的指针,但是不可以定义void类型的变量.void指针一般只在指针所指向的数据类型不确定的时候使用
- 指针运算
    - 指针是一种数据类型
    - 指针++或者指针--表示的是指针相对应的内存区域的向前或者向后的一个内存空间,同样的,指针+n表示指针后的第n个空间
    - *(p1+n1)表示p1后第n1个位置处的数据的内容,它也可以写作p1[n1],这种写法和*(p1+n1)的写法是完全等价的,同样*(p1-n1)可以写作p1[-n1]
    - 不同类型的指针或指针与非0整数之间的关系运算是毫无意义的
    - 但是指针变量可以和0进行比较,0专门用来表示空指针,也就是一个不知想任何有效地址的指针
    - 赋值给指针变量的必须是指针常量或地址变量,不能是非0的整数,但是可以给一个指针变量赋值未0,这时候表示该指针是一个空指针,不指向任何地址
    > int *p=0;//声明一个int类型的指针p
      p=0;//将p设置为空指针,不指向任何地址
    - 空指针也可以使用NULL来表示,比如
    > int *p=NULL;
    - NULL是一个在很多文件中都有定义的宏,被定义为0
        - 有时候需要使用NULL来将一个指针设置为空指针,因为有时候在声明一个指针的时候,并没有一个确定的地址值可以赋给它,当程序运行到某个时刻的时候才会将某个地址赋值给该指针.这样子,从指针变量诞生到它具有确定的值之前这一段时间,其中的值是不确定的
- 用指针处理数组元素
    - 指针加减法的特点使得指针特别适合处理存储在一段连续内存空间上的同类数据.而数组恰好是具有一定数据关系的若干类型变量的集合体,数组元素的存储在物理上也是连续的,数组名就是数组存储的首地址,这样可以使用指针来对数组及其元素进行方便而快速的操作 
    - 这三种形式出现在形参表中都是等价的
        - void f(int p[]);
        - void f(int p[3]);
        - void f(int *p);
- 指针数组
    - 如果一个数组的每个元素都是指针变量,这个数组就是指针数组,指针数组的每个元素都必须是同一类型的指针
        - 声明一维指针数组的语法形式为:
            - 数据类型*数组名[下标表达式]; 
        - 调用二维数组的元素(嵌套,维数越多越复杂)
            - *(*(array2+i)+j);这个表示的是array2数组第i行第j列的值,在这里可以把array看作是存储指向变量的指针的一维数组
            - 对于多维数组,在形式上可以当作相维数-1的一个多维指针数组
- 用指针作为函数参数
    - 当需要在不同的函数之间传送大量的数据的时候,程序执行时调用函数的开销就会比较大,如果需要传递的数据是存放在一个连续的内存区域中,就可以只传递数据的起始地址,而不必传递数据的值,这样子减少开销,提高效率.
    - 函数的参数不仅仅可以是基本类型的变量,对象名,数组名或引用,而且可以是指针.如果以指针作为形参,在调用的时候实参将值传递给形参,也就是使形参和实参指针变量指向同一个内存地址.这样子子函数运行过程中,通过形参指针对数据值的改变也同样影响着实参指针所指向的数据值
        - 指针作为函数的形参有三个作用
            1. 使实参与形参指针指向共同的内存空间,以达到参数双向传递的目的,就是通过在被调函数中直接处理主调函数中的数据而将函数的处理结果返回其调用者
            2. 减少函数调用的时候数据传递的开销
            3. 通过指向函数的指针传递函数代码的首地址
            > 如果函数体中不需要通过指针改变指针所指向对象的内容,应当在函数表中将其声明为指向常量的指针,这样使得常对象被取地址后也可以作为哦该函数的参数
- 指针型函数
    - 指针也可以是函数的返回值
        - 指针型函数的一般定义形式为:
            - 数据类型 * 函数名(参数表)
            {
                函数体
            }
            - 数据类型表明函数返回指针的类型;函数名和*标识了一个指针型的函数;参数表中使函数的形参列表
- 指向函数的指针
    - 在程序运行的时候,不仅数据要占用内存空间,指向程序的代码也被调入内存并占据一定的空间.每一个函数都有函数名,实际上这个函数名就表示函数的代码在内存中的起始位置,这么看来,调用函数的通常形式"函数名(参数表)"的实质就是"函数代码首地址(参数表)"
    - 函数指针就是专门用来存放函数代码首地址的变量.在程序中可以向使用函数名一样使用指向函数的指针来调用函数.也就是说一旦函数指针指向了某个函数,它与函数名便具有同样的作用.函数名在表示函数代码起始地址的同时,也包括函数的返回值类型和参数的类型(个数,类型,排列次序)因此在通过函数名调用函数的时候,编译系统能够自动检查实参与形参是否相符,用函数的返回值参与其他运算的时候,能自动进行参数一致性检查
        - 声明一个函数指针的时候,也需要说明函数的返回值,形式参数列表,其一般语法:
            - 数据类型(*函数指针名)(形参表)
        - 数据类型说明函数指针所指函数的返回值类型,第一个圆括号中的内容指明一个函数指针的名称;形参表则列出了该指针所指函数的形参个数和类型
        > 由于对函数指针的定义在形式上有些复杂,如果在程序中多次出现这样的定义,多次重复这样的定义会相当繁琐,一个很好的解决方法就是使用typedef,比如:typedef int (*DoubleIntFunction)(double);
        - 这声明了DoubleIntFunction为"有一个double形参,返回类型为int的函数的指针"类型的别名.需要声明这一类型的变量的时候,可以直接使用:DoubleIntFunction funcPtr;
            - 这声明了一个具有该类型的名称为funcPtr的函数指针,用typedef可以很方便的为复杂类型起别名
        - 函数指针在使用之前也要进行赋值,使指针指向一个已经存在的函数代码的起始地址.一般语法为:
            - 函数指针名=函数名;
            - 等号右边的函数名所指出的必须是一个已经声明过的,和函数指针具有相同返回类型和相同参数表的函数.在赋值之后,就可以通过函数指针名来引用这个指针指向的函数
            - 定义好一定格式的函数指针之后，需要给这个函数指针初始化指向需要的函数，之后这个函数指针可以当作函数名使用     
- 对象指针                    
    - 对象指针的一般概念
        - 每一个对象在初始化之后都会在内存中占有一定的空间，因此，既可以通过对象名，也可以通过对象地址来访问一个对象。虽然对象同时包含了数据和函数两种成员，和一般变量存在不同之处，但是对象所占据的内存空间只是用于存放数据成员的，函数成员不在每一个对象中存储副本，对象指针就是用于存取对象地址的变量。
            - 对象指针遵循一般变量指针的各种规划，声明对象指针的一般语法为：
                - 类名 *对象指针名；
            - 就像通过对象名来访问对象的成员一样，使用对象指针一样可以方便的访问对象的成员，语法形式为：
                - 对象指针名->成员名
                - 这种形式与(*对象指针名).成员名 的访问形式是等价的 
- this指针
    - this指针是一个隐含于每一个类的非静态成员函数中的特殊指针(包括构造函数和析构函数),它用于指向正在被成员函数操作的对象
        - this指针实际上是类成员函数的一个隐含参数.在调用类的成员函数的时候,目的对象的地址会自动作为该参数的一个隐含参数.调用类的成员函数的时候,目的对象的地址会自动作为该参数的值,传递给正在被调用的成员函数,这样被调函数就能够通过this指针来访问目的对象的数据成员.对于常成员函数来说,这个隐含的参数是常指针类型的
    - 每次对成员函数的调用的时候都存在一个目的对象,this指针就是指向这个目的对象的指针
        - 对于每个对象,在执行类似于getX之类的函数的时候获取它的横坐标,所使用的语句是:return x;系统需要区分每次执行这条语句的时候被复制的数据成员到底是属于哪一个对象,使用的就是这个this指针,对于系统来讲,每次调用都相当于执行 return->x;this指针明确的指出了成员函数当前操作的数据所属的对象
        - 实际过程:this指针是成员函数的一个隐含形参,当通过一个对象调用函数的时候,系统先将该对象的地址通过该参数传递给成员函数,成员函数对对象的数据成员进行操作时,就隐含使用了this指针
        - this是一个指针常量,对于常成员函数,this同时又是一个指向常量的指针.在成员函数中,可以使用*this来标识正在调用该函数的对象
            - 当局部作用域中声明了与类成员同名的标识符的时候,对该标识符的直接引用代表的是局部作用域中所生命的标识符,这时为了访问该类成员,可以使用this指针
- 指向类的非静态成员的指针
    - 类的成员自身也是一些变量,函数或者对象等,因此也可以将他们的地址存放在一个指针里面,这样,就可以使用指针直接指向对象的成员,进而可以通过这些指针访问对象的成员
        - 指向对象成员的指针在使用之前需要进行声明,再赋值,然后引用,因此需要声明指向该对象所在类的成员的指针.声明指针语句的一般形式为:
            > 类型说明符 类名 :: *指针名;//声明指向数据成员的指针
            > 类型说明符 (类名::*指针名)(参数表);//声明指向函数成员的指针
        - 声明了指向成员的指针之后,需要对其进行赋值,也就是所要确定指向类的哪一个成员.对类的数据成员的赋值的一般语法:
            - 指针名 =&类名::数据成员名
        > 对类成员取地址的时候,也需要遵循访问权限的规定,也就是说,在一个类的作用域之外不能够对它的私有成员取地址
        - 由于类是通过对象而实例化的,在声明类的对象时才会为具体的对象分配内存空间.这时只要将对象在内存中的起始位置与成员指针中存放的相对偏移结合起来就可以访问到对象的数据成员了,访问数据成员的时候,这种结合可以通过以下两种形式实现:
            1. 对象名.*类成员指针名
            2. 对象指针名->*类成员指针名
        - 成员函数指针在声明之后要用一下形式的语句对其赋值
            - 指针名=&类名::成员函数名
            > 常成员函数与普通成员函数具有不同的类型,因此能够被常成员函数赋值的指针,需要在声明的时候明确写出const关键字
        - 调用成员函数:
            - (对象名.*类成员指针名)(参数表)
            - (对象指针名->*类成员指针名)(参数表)
            > 成员函数指针的声明,赋值和使用过程中的返回值类型,函数参数表一定要互相匹配
        - 指向类的静态成员的指针
            - 对类的静态成员的访问是不依赖对象的,因此可以用普通的指针来指向*和访问静态成员
# 动态内存分配
- 动态内存分配技术可以保证程序在运行过程中按照实际需要申请适量的内存,使用结束后还可以释放,这种在程序运行过程中申请和释放的存储单元也称为堆对象,申请和释放过程一般称为建立和删除
- 在cpp程序中建立和删除对对象使用两个运算符:new和delete
    - 运算符new的功能是动态分配内存,或者称为动态创建堆对象,语法形式为:
        - new数据类型(初始化参数列表);
    - 该语句在程序运行过程中申请分配用于存放指定类型数据的内存空间,并且根据初始化参数列表中给出的值进行初始化.如果内存申请成功,new运算便返回一个指向新分配内存首地址的类型的指针,可以通过这个指针对堆对象进行访问;如果申请失败,会抛出异常
- 如果建立的对象是一个基本类型变量,初始化过程就是赋值,例如:
    >   int *point;point=new int(2);
- 动态分配了用于存放int类型数据的内存空间,并将初值2存入该空间中,然后将首地址赋值给指针point
    > 对于基本数据类型,如果不希望再分配内存后设定初值,可以把括号省去,比如:int *point=new int;
    - 如果保留括号,但是括号中不写任何数据,则表示用0对该对象初始化,例如:
        > int *point=new int();
    - 如果建立的对象是某一个类的实例对象,就是要根据初始化参数列表的参数类型和个数调用该类的构造函数
- 用new建立一个类的对象的时候,如果该类存在用户定义的默认构造函数,则new T 和new T()这两种写法的效果是相同的,都会调用这个默认构造函数.但是若用户未定义默认构造函数,使用 new T创建对象的时候,会调用系统生成的隐含的默认构造函数,使用new T()创建对象的时候,系统除了执行默认构造函数会执行的那些操作外,还会为基本数据类型和指针类型的成员用0赋初值,而且这一个过程是递归的.如果该对象的某个成员对象也没有用户定义的默认构造函数,那么对该对象的基本数据类型和指针类型的成员,同样也会被0赋初值
# delete
- 运算符delete用来删除由new建立的对象,释放指针所指向的内存空间,格式为:
    - delete 指针名;
- 如果被删除的是对象,那么该对象的析构函数就会被调用.对于用new建立的对象,只能使用delete进行一次删除操作.如果对于同一块内存多次使用delete进行删除会导致运行cup五
    - 用new分配的内存,必须用delete加以释放,否则会导致动态分配的内存无法回收,使得程序占据的内存越来越大,这叫做内存泄漏
- 使用运算符new也可以创建数组类型的对象,这时需要给出数组的结构说明.用new运算符动态创建一维数组的语法形式为:
    > new 类型名 [数组长度];
    - 其中数组长度指出了数组元素个数,它可以是任何能够得到正整数值的表达式
- 用new动态创建一维数组的时候,在方括号后仍然可以加小括号(),但小括号内不能带任何参数.是否加()的区别在于,不加(),则对数组的每个元素初始化,与执行new T时所进行初始化的方式相同;加(),则与执行new T()所进行初始化的方式相同.
    - 比如,这样子生成一个整形数组
        - int *p=new int [10]();
        - 则可以方便的为动态创建的数组用0值初始化
    - 如果是new建立的数组,用delete删除的时候在指针名前面要加[],格式是这样的:
        - delete[] 指针名;
- 建立和删除数组的过程使得程序略显得繁琐,更好的方法是将数组的建立和删除的过程封装起来,形成一个动态数组类.
    - 在动态数组类中,通过类的成员函数访问数组元素,可以在每次访问之前检查以下下标是否越界,使得数组下标越接的错误能够及早被发现
        - 这种检查可以通过cpp的assert来进行,assert的含义是断言,它是标准cpp的cassert头文件中定义的一个宏,用来判断一个条件表达式的值时是否为true,如果不是true,那么程序就会中止,并且报告出错误,这样就很容易将错误定位
        - 一个程序一般有两种模式编译--调试(debug)模式和发行(release)模式,assert只在调试模式下生效,而在法航模式下不执行任何操作,而用户的不当输入造成的错误,则应当使用其他方式加以处理
            > assret的使用方法:比如:assert(index==0);
        - 用new操作也可以创建多维数组,形式如下:
            - new 类型名T [数组第一维长度][数组第二维长度]···;
                - 其中数组第一维长度可以是任何结果为正整数的表达式,而其他各维数组长度必须是结果为正整数的常量表达式.如果内存申请成功,new运算返回一个指向新分配内存的首地址的指针,但不是T类型指针,而是一个指向T类型数组的指针,数组元素的个数为除最左边一维外各维下标表达式的乘积
                    > 比如:float *fp;fp=new float[10][25][10];
                    - 这样子会产生错误,这是因为在这里new操作产生的是指向一个$25\times 10$的二维float类型数组的指针,而fp是一个指向float类型数据的指针.
                    > 正确的写法应该是:float(*cp)[25][10];cp=new float [10][25][10];
                    - 如此得到的指针cp,既可以作为指针使用,也可以像一个三维数组名一样使用
# 用vector创建数组对象
- cpp标准库提供了被封装的动态数组----vector.这种被封装的数组可以具有各种类型,这就使我们免去了那些重复性的工作.vector不是一个类,而是一个类模板
    - 用vector定义动态数组的形式为:
        - vector <数组类型>数组对象名(数组长度);
            - 尖括号中的类型名表示数组元素的类型.数组长度是一个表达式,表达式中可以包含变量
        > 下面定义一个大小为10的int型动态数组对象arr:int x;vector<int>arr(x);
        - 与普通数组不同的是,使用vector定义的数组对象的所有元素都会被初始化.如果数组的元素类型为基本数据类型,则所有元素都会被以0初始化;如果数组元素为类类型,则会调用类的默认构造函数初始化
        - 因此如果以此形式定义的vector动态数组,需要保证作为数组元素的类具有默认构造函数.
        - 初值也可以自己指定,但只能为所有元素指定相同的初值,形式为:
            - vector<元素类型>数组对象名(数组元素,元素初值);
        - 对vector数组对象元素的访问方式,与普通数组具有相同的形式:
            - 数组对象名[下标表达式]
        - 但是vector数组对象的名字表示的就是一个数组对象,而非数组的首地址,因为数组对象不是数组,而是封装了数组的对象
        - vector定义的数组对象具有一个重要的成员函数size(),它会返回数组的大小.vector的大小可以扩展
# 深复制与浅复制
- 隐含的构造函数完成的是浅复制
- 浅复制的弊端:由于两个对象共用了一块内存空间,因此该空间被两次释放,于是导致运行错误.解决这个问题的方法是编写复制构造函数,实现深复制
# 字符串
- 和c语言一样,在cpp的基本数据类型中没有字符串变量.
- 在c语言中使用字符型数组来存放字符串,在cpp中也是可以使用这种方法的.在cpp的库中还定义了string类
- string类
    - 严格来说,string并非一个独立的类,而是类模板basic_string的一个特化实例.不过对于string的用户来说,它的特点和一个类无异,因此可以把它当作一个类来看待
    - 为了简明起见,函数原型是经过简化的,与头文件中的形式不完全一样
    - 构造函数原型
        - string();//默认构造函数,建立一个长度为0的串
        - string(const string& rhs);//复制构造函数
        - string(const char* s);//用指针s所指向的字符串常量初始化string类的对象
        - string(const string& rhs,unsigned int pos,unsigned int n);//将对象rhs中的串从位置pos开始取n个字符,用来初始化string类的对象,串中的第一个字符的位置为0
        - string (const char* s,unsigned int n);//用指针s所指向的字符串中的前n个字符初始化string类的对象
        - string (unsigned int n,char c);//将参数c中的字符重复n次,用来初始化string类的对象
        - 由于string类具有接受const char*类型的构造函数,因此字符串常量和用字符数组表示的字符串变量都可以隐含的转换为string对象,可以直接使用字符串常量对string对象初始化:string str="hello world"
- string类的操作符
- |操作符|示例|注释|
    |---|---|---|
    |+|s+t|将串s和t链接成一个新串|
    |=|s=t|用t更新s|
    |+=|s+=t|等价于s=s+t|
    |==|s==t|判断s与t是否相等|
    |!=|s!=t|判断s与t是否不等|
    |<|s<t|判断s是否小于t|
    |<=|s<=t|判断s是否小于等于t|
    |[]|s[i]|访问串中下标为i的字符|
- 之所以能够通过上面的操作符来操作string对象,是因为string类对这些操作符进行了重载,上面讲的关于字符串的比较,是按照字典序的比较
- 常用成员函数的功能简介
    - 好多啊,不码了
    - 使用的很多的函数:
        - unsigned int length()const;//返回串的长度(字符个数)
        - 如果想要从键盘上读入字符串,直到行末位为止,不以中间的空格作为输入的分隔符,可以使用头文件string中定义的getline
        > getline (cin,s2);
        - 这个时候,如果从键盘输入字符串,那么整个字符串都会被赋值到s2,实际上表示输入字符串时只可以以换行符作为分隔符.getline还允许在输入字符串的时候增加其他分隔符,使用的方法时把可以作为分割符的字符作为第三个参数传递给getline
        > 加入逗号作为分隔符

        > getline(cin,s2,',');
        #指针与引用
- 指针是c语言也有的，cpp引入了引用
- 指针与引用的区别：
    - 指针可以被多次赋值，而引用只能在初始化的时候确定引用的对象，因此引用的功能和一个指针常量差不多
    - 指针常量与引用使用形式的比较
        |操作|T类型的指针变量|对T类型的引用|
        |---|---|---|
        |定义并用v初始化（v是T类型变量）|T *const p=&v；|T &r=v；|   
        |取v的值|*p|r|
        |访问成员m|p->m|r.m|
        |读取v的地址|p|&r|                       
    - 引用的本身（不是引用的对象）的地址是不可以被获取的，引用占用的空间完全的被隐藏了起来
    - 存在函数指针，但是不存在函数引用
    - const_cast只用于将常指针转换为普通指针，将常引用转换为普通引用，而不用于将常对象转换为普通对象
# 继承与派生
- 最高层是抽象程度最高的,下层具有上层的特性,同时加入了自己的新特性,而最下层是最具体的.
    - 由下到上是一个抽象的过程,上下层之间的关系就可以看作类与派生类的关系
- 继承就是从先辈那边得到属性和行为特征
    - 类的继承,就是新的类从已有的类那里得到已有的特性,从已有类产生新的类的过程称为派生
    - 类的继承和派生机制允许程序员在原有类特性的基础上进行更加具体的修改和扩充
    - 原有类产生的新类具有原有类的特性,同时可以加入自己需要的新的特性
- 原有的类称为基类或父类,产生的新类称为派生类或子类
    - 派生类同样可以作为基类派生出其他新的类
    - 通过类的派生可以建立具有共同关键特性的对象家族,从而实现代码的重用.
        - 继承和派生机制对于已有的程序的发展和改进是很有利的
# 派生类的定义
- 在cpp中,派生类的一般语法:
    - class 派生类名:继承方式 基类名1,继承方式 基类名2,...,继承方式 基类名n
    {
        派生类成员声明;
    }
    - 基类名是已经有的类,派生类名是继承已有的类生成的新的类的名字
    - 一个派生类可以有多个基类,这成为多继承;一个派生类只有一个直接基类的情况称为单继承
        - 在类族中,直接派生出的某类的基类称为直接基类,基类的基类甚至更高层的基类称为间接基类
        - 继承方式规定了如访问从基类继承的成员
        - 派生类成员指的是除了从基类继承来的所有成员外,新增加的数据和函数成员,是类在继承基础上的进化和发展
- 派生类生成过程
    1. 吸收基类成员
        - 包含了它的基类中的除了构造和析构函数之外的所有成员,在派生过程中构造函数和析构函数都不被继承
    2. 改造基类成员
        - 如果在派生类中声明了和基类中名字一样的新成员(如果是成员函数,要是参数表不同那么是重载),那么屏蔽外层的成员,使用在派生类中定义的新成员,这叫做同名隐藏
    3. 添加新的成员
        - 由于构造函数和析构函数是不能够被继承的,所以要实现一些初始化或者扫尾工作的时候需要在派生类中加入新的构造和析构函数
- 访问控制
    - 公有继承
        - 当类的继承方式为共有继承的时候,原来基类的公有成员和保护乘员的访问属性不变,私有成员不可以直接访问.
        - 派生类的其他成员可以直接访问基类的公有成员和保护成员,但是不能够直接(注意直接)访问基类的私有成员
    - 私有继承
        - 当类的继承方式为私有继承的时候,基类的公有成员和保护成员都以私有成员的属性出现在派生类中,这些继承来的成员/成员函数在类中是私有成员,可以被直接引用但是不能够被外部成员使用.
        - 基类的私有成员还是无法被派生类直接调用
    - 保护继承
        - 基类的公有成员和保护成员都以保护成员的形式出现在派生类中
        - 基类的私有成员还是无法直接访问
        - 这边顺带提起以下在普通的类中的保护成员
            - 保护成员在类中的时候和私有成员一样,只有在继承的时候才与私有成员不一样.
            - 保护成员能够被本类和子类访问,不能被外部访问
            - 私有成员只能被本类访问
        - 注意:如果B是A的派生类,B的成员函数只能通过B类访问A的保护成员,不能直接通过A来访问A的保护成员
# 类型兼容规则
- 兼容性规则指的是在需要基类对象的任何地方,都可以使用共有派生类的对象来替代
    - 派生类的对象可以隐含转换为基类的对象
    - 派生类的对象可以初始化基类的引用
    - 派生类的指针可以隐含转换为基类的指针
- 在替代之后,派生类对象就可以作为基类的对象使用,但只能使用从基类继承的成员
- 通过类型兼容规则我们可以知道:
    - 可以在基类对象出现的场合使用派生类的对象来替代
    - 多态可以保证在类型兼容的前提下,基类、派生类以不同的方式来相应相同的信息
# 派生类的构造和析构函数
- 构造函数
    - 派生类的构造函数只对派生类的成员进行初始化，对于从基类继承下来的成员，其初始化工作还是由基类的构造函数完成
    - 派生类的成员是由所有的继承到的基类的成员和新增的成员共同组成
        - 构造派生类的对象的时候，需要对基类的成员对象和新增成员对象进行初始化
        - 在构造派生类的对象的时候，会首先调用基类的构造函数，来初始化它们的数据成员，然后按照构造函数初始化列表中指定的方式初始化派生类新增的成员对象，最后执行派生类构造函数的函数体
            - 派生列构造函数的一般语法形式：
            > 派生类名::派生类名(参数表):基类名1(基类1初始化参数表),...,基类名n(基类n初始化参数表),成员对象名1(成员对象1初始化参数表),...,成员对象名m(成员对象m初始化参数表)
            {
                派生类构造函数的其他初始化操作
            }
            - 派生类的构造函数名与类名相同，在构造函数的参数表中，需要给出初始化基类数据和新增成员对象所需要的参数。在参数表之后，列出需要使用参数进行初始化的基类名和参数表。对于使用默认构造函数的积累，可以不用给出类名。对于成员对象，如果是使用默认构造函数，也不需要写出对象名和参数表
        - 什么时候需要声明派生类的构造函数
            - 如果对基类初始化时，需要调用基类的带有形参表的构造函数的时候，派生类就必须声明构造函数
            - 如果不需要调用基类带参数的构造函数，也不需要调用新增成员对象的带参数有的构造函数，派生类可以不生命构造函数，全部采用默认的构造函数，这时新增成员的初始化工作可以用其他公有函数来完成
            - 当派生类没有显式的构造函数的时候，系统会隐含生成一个默认构造函数。这个函数会使用基类的默认构造函数对继承自基类的数据初始化，并且调用类类型的成员对象的默认构造函数，对这些成员对象初始化
        - 派生类构造函数执行一般次序如下：
            1. 调用基类构造函数，调用顺序按照他们被继承时声明的顺序（从左往右）
            2. 对派生类新增的成员对象初始化，调用顺序按照他们在类中的声明的顺序
            3. 执行派生类的构造函数体中的内容
        - 构造函数初始化列表中的基类名,对象名之间的次序是无关紧要的,他们出现的顺序可以是任意的.因为无论他们的顺序是怎么样的,基类构造函数的调用和各个成员对象的初始化顺序都是确定的                                                                                                    































# 还需要巩固的/不懂的
- 浅复制和深复制





















> 薄弱环节揭露:友元声明后的的定义






