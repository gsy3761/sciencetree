一般来说，计算机的部分分为物理上的（硬件上的）和逻辑上的（软件上的）认识。
显示器：
挑选显示器需要注意四个方面：色域，色差，刷新率，色深
关于色域：
色域普遍使用的有三个版本：NTSC，RGB，Adobe RGB
一般来说，Adobe RGB是非常专业的图像处理师使用的，色域最大（能显示的颜色的范围最大）
对于RGB和NTSC，也是两个色域的标准，99%的RGB和72%的NTSC能显示的颜色的范围几乎一样。很多厂商会在这方面做文字游戏。

关于色深：
截至现在，色深一般分为8位色深和10位色深。因为合成一个颜色是由三种原色混合而成的，比如8位色深中的白色（255，255，255）绿色（0，0，255）255是28种，所以对于10位的色深就是1024种。

关于色差：
一般色差的衡量标准是delta e，一般这个数值越小越好，色差也就越小。分为静态色差和动态色差。举一个例子：静态色差在玩枪战游戏的时候更容易发现躲在暗处的敌人，而动态色差现在的厂商普遍做的非常好。

关于刷新率：
目前屏幕的刷新率大体分为三种：144hz，120hz，60hz。
如果刷新率位100hz，那么他的意思是每一秒钟刷新100张照片，换算成毫秒单位就是10ms一张图片。
除此之外，在挑选显示器的时候，要注意所拥有的空间和显示器的大小。

关于尺寸与分辨率与人眼距离显示器的距离：
我们讲的英寸是对角线的长度，分辨率1080P实际上已经足够了。
关于屏幕的尺寸应该根据人眼距离显示器的距离来选取，这时候可以合理的使用勾股定理，凭借人眼距离屏幕的距离以及视角的范围来选取显示器的大小。
一般来说：一个人能够注意到的视角范围是135°，再升级一步，在意的范围是60°，但是在40°到60°之间人是不可能全部在意的，在这个区域内有很大一部分是凭借大脑自动补全（yy）出来的。一般看电影最佳的观影角度是40°，一般这个视野角度能够给人提供最大的观影（娱乐/打游戏）体验。
屏幕的比率主流是以下三种：16：9  21：9   32：9
即使使用了21：9之类的显示器，但是很多的电影，电视剧，游戏等主流支持的是16：9的，所以在使用类似21：9的显示屏的时候在左右两边会出现大黑边。然而对于一个正常人，更能影响一个人的是左右的视野，上下的视野其次。关于屏幕素质，有两个体系：PPI（pixel per inch）意思是每英寸内的像素点；PPD意思是每一度的像素点数。


硬盘：



计算机的二进制运算：
二进制数的运算有2种大类：
逻辑运算：∨，∧，NOT.  按位进行，不考虑进位
算术运算:   +,   - , x ,  / .  从低位到高位逐位进行，需考虑低位的进位(借位)  
逻辑运算可以用门电路（与门、或门、非门等）实现
算术运算可以表达为逻辑运算，因此二进制数的四则运算同样也可以使用门电路来实现
成千上万个门电路可以制作在集成电路上，工作速度极快，因而能高速度地完成二进制数的各种运算 

比特只有0和1两个符号，具有2个状态的器件和装置就能表示和存储比特，而制造两个稳定状态的电路又很容易
比特的运算规则很简单，使用门电路就能高速度地实现二进制数的算术和逻辑运算
比特不仅能表示“数”，而且能表示文字、符号、图像、声音，可以毫不费力地相互组合，开发“多媒体”应用



影响cpu的因素：
字长（位数）
指通用寄存器和定点运算器的宽度（即二进制整数运算的位数）
指令系统
指令的类型、数目和功能等都会影响程序的执行速度
逻辑结构（微架构）
CPU包含的定点运算器和浮点运算器的数目、采用的流水线结构和级数、指令分支预测的机制、执行部件的数目等
高速缓存（cache）的容量与结构    
主频（CPU内部时钟频率）
指CPU芯片中电子线路（门、触发器）的工作频率，它决定着CPU芯片内部数据传输与操作速度的快慢    
内核数目：1个、2个、···、6个、8个甚至更多	



bios里面自动包含的程序
加电自检程序程序（POST）
  (Power On Self Test)用于检测计算机硬件故障
系统自举程序（Boot）
 启动计算机工作，加载并进入操作系统运行状态
CMOS设置程序
 设置系统参数：日期、时间、口令、配置参数等
常用外部设备的驱动程序（Driver）
 在计算机启动阶段实现对键盘、显示器、软驱和硬盘等常用外部设备输入输出操作的控制
主板的作用：安装所有的电子器件、电路与连接件
ROM BIOS:存放最基础的软件—基本输入/输出系统(BIOS)
CMOS存储器：存放硬件配置信息和系统基本参数（日期、时间、口令等）




计算机基本硬件知识的普及：
计算机从根本上分为运算器，存储器，控制器，输入输出设备
计算机的硬件组成：
内部硬件：CPU（中央处理器）；GPU（图形处理器/显卡）；RAM（内存）；ROM（硬盘）；mother board（主板）
外部硬件：显示器；机箱；电源；鼠标；键盘
内存（为CPU工作）
显存（为GPU工作）
内存=运行内存=内存条；内存大电脑不一定快，但是内存不够会导致电脑卡顿

关于显卡GPU的基本知识普及：
和CPU放在一起的叫核心显卡，简称核显；
放在主板上的叫集成显卡，简称集显；
独立出来单独工作的叫做独立显卡，简称独显；
一般从性能的角度来说，独显>核显>集显
在显存足够的情况下，显存的大小完全不影响显卡的性能。

主板的基本知识普及：
主板负责把硬件连接起来
主板上的两个芯片：北桥芯片和南桥芯片
主板型号以北桥芯片型号命名
主板上的软件：BIOS（基本输入输出系统）
BIOS是连接硬件和操作系统的桥梁
好主板=使用稳定     但是好主板≠性能强

电子计算机以电子元件划分发展阶段
内存可以直接访问CPU//这边要特别注意cache
IP地址由4个byte组成，分配IP地址所对应的域名可以是多个
操作系统诞生于第三代计算机
在windows系统中，选定文件加上shift+delete键就可以完全删除一个文件
汇编语言实质上时符号化的汇编语言
IP的功能是传输


CPU所作的是解释和运行最终转换成机器语言的程序内容
CPU和内存是由许多晶体管组成的电子部件，通常称为IC—集成电路
CPU内部由寄存器，控制器，运算器和时钟组成，各部分之间由电流信号相互沟通。
寄存器用来暂存数据，指令等存储对象，可以把寄存器看成是内存的一种。一个CPU内部会与很多寄存器。
控制器负责把内存上的指令，数据等读入寄存器，并根据指令的执行结果来控制计算机。
运算器负责运算从内存读入寄存器的数据
时钟负责发出CPU开始计时的时钟信号（有些计算机的时钟位于计算机CPU的外部），时钟频率越高，CPU运行的速度就越快

一般程序运行的流程是这样的：
用c语言等高级语言编写程序---将程序编译后转换成机器语言的EXE文件---程序运行时，在内存中生成EXE文件的副本---CPU解释并执行程序的内容


内存：
通常指的内存是计算机的主存储器，简称主存。主存通过控制芯片等与CPU相连，主要负责存储指令和数据。主存由可读写元素构成，每个字节都带有一个地址编号。CPU可以通过该地址读取主存中的指令和数据，也可以写入数据。主存中的指令和数据会随着计算机的关机而自动清除。


具体流程：
程序启动后，根据时钟信号，控制器会从内存中读取指令和数据。通过对这些指令加以解释和运行，运算器就会对数据进行运算，控制器根据该运算结果来控制计算机。

程序是把寄存器当作对象来描述的。
汇编指的是：将汇编语言编写的程序转换成机器语言的过程。
机器语言转换成汇编语言的过程就叫反汇编。

作为一个程序员，只要深入了解CPU四个部分中的寄存器这一个部分就可以了。CPU是寄存器的集合体

寄存器主要分为八种：
累加寄存器：存储执行运算的数据和运算后的数据
标志寄存器：存储运算处理后CPU的状态
程序计数器：存储下一条指令所在内存的地址，决定程序的流程
基址寄存器：存储数据内存的起始地址
变址存储器：存储基址存储器的相应地址
通用存储器：存储任意数据
指令存储器：存储指令。CPU内部使用，程序员无法通过程序对该寄存器进行读写操作
栈存储器：存储栈区域的起始地址
键盘：
机械键盘：轴体是机械键盘的核心组件
基本上现在的轴体分为青轴，茶轴，黑轴，白轴，红轴
一般来说：青轴更加适合打字，段落感最强；茶轴介于打字和游戏之间，段落感稍微逊色于青轴，黑轴适合于游戏，红轴和青轴最大的差别是没有段落感，是直上直下的按压方式，手感十分轻盈，算得上是轻量级的黑轴，红轴键盘的最大特点是可以进行可编程按键，可以重新设定多种按键需求。白轴现在出现的比较少，白轴和青轴类似，但是按压所需要的力量更大。

键程：一个键能够按下去的距离
多少键无冲突：能够一下按下多少个键

计算机的基础知识：
计算机的工作原理：存储程序控制原理
IP是指令指针，作用是保存将要执行下一条指令的地址
第一代计算机使用电子管，第二代使用晶体管，第三代使用中小规模集成电路，第四代使用大规模集成电路
一个CPU能执行的全部指令称为指令系统，指令（操作码，操作数）
单片机是将CPU，内存储器和I/O接口集成在一个芯片上的计算机
经过压缩的图像格式（JPEG,TIF,PNG）微型计算机的运算器，控制器以及内存储器的总成是主机

Cache高速缓冲区>RAM>硬盘>软盘
Cache存放着程序和数据，主要目的是解决CPU与辅助存储器之间速度不匹配问题
以MIPS衡量计算机性能，指的是计算机的运算速度

总线：
总线(BUS)分为两大种：
系统总线内部总线和外部总线，用于实现主板上各大不见之间的连接
数据总线（传递信息）：
特点：1、总是双向总线
	  2、总线线数和机器字长一致
	  3、用来传输数值型数据
数据总线（Data Bus）：在CPU与RAM之间来回传送需要处理或是需要储存的数据。
地址总线（Address Bus）：用来指定在RAM（Random Access Memory）之中储存的数据的地址。
控制总线（Control Bus）：将微处理器控制单元（Control Unit）的信号，传送到周边设备。
扩展总线（Expansion Bus）：外部设备和计算机主机进行数据通信的总线，例如ISA总线，PCI总线。
局部总线（Local Bus）：取代更高速数据传输的扩展总线。

如果讲到寻址能力20根，就是指220字节


存储：
磁盘容量=磁头数×柱面数×扇区数×512字节

显示器由监视器和显示卡两部分组成，按显示设备所用的显示器件分类，常见的有CRT显示器，LCD显示器，LED显示器以及等离子显示器

微型计算机常使用 缓存，内存和外存储器三级存储结构






对于程序员来说，CPU就是各种功能寄存器的结合体
程序计数器，累加寄存器，标志寄存器，指令寄存器，栈寄存器都只有一个，基址寄存器、变址寄存器、通用寄存器都不止一个。

操作系统指的是管理和控制计算机硬件和软件资源的计算机程序。

通俗的讲：
面向过程：注重细节，每一步都精确好
面向对象：把一个一个事情封装起来变成类，然后用类

数据类型：数组类型、结构体类型、共用体类型
操作系统是以文件为单位进行操作的
按照数据的组织形式分为：
ASCII文件（文本文件）每一个字节放一个ASCII码，便于对字符进行逐个处理，也便于输出字符。但是一般内存占用较多，而且要花费转换时间。
二进制文件：把内存中的数据按其在内存中的存储形式原样输出到磁盘上存放。他可以节省转换时间和存储空间，但是一个字节并不对应一个字符，不能直接输出字符形式。

C语言对文件的处理方法：
缓冲文件系统：系统自动在内存区为每一个正在使用的文件开辟一个缓冲区。用缓冲文件系统进行输入输出又称为高级磁盘输入输出。

另外一个文件处理方法：
非缓冲文件系统：系统不自动开辟确定大小的缓冲区，而由程序为每个文件设定缓冲区。这称为低级输入输出系统。越是低级的越接近底层。

比如UNIX系统处理文本文件是前者处理方法，处理二进制文件是后者处理方法。

溢出是指运算的结果超出了寄存器的长度范围
奇偶校验是指检查运算结果的值是奇数还是偶数
标志寄存器会保存累加寄存器运算结果是正数，0，还是负数，溢出，奇偶校验



标志寄存器：运算结果的正，零，负三个结果由标志寄存器的三个位表示。











函数的调用机制：通过程序计数器的值设定成函数的存储地址来实现。对于c语言，一行c语言编译后一般会变成很多行机器语言，所以地址是离散的。

Call指令：
在将函数的入口地址设定到程序计数器之前，call指令会把调用函数后的指令地址存储在名为栈的主存中。
Rturn指令：把保存在栈中的指令地址设定到程序计数器中。
实际上各地址存储的应该是变换成机器语言后的程序。
总的来说：函数调用的时候会使用call指令，在返回主函数的时候使用的是return指令。




栈（stack）：本意是“干草等堆积如山”。在程序领域中，通常使用该词来表示不断的存储各种数据的内存区域。因为有栈，所以函数调用之后能够正确的返回调用前的地址。


通过地址和索引实现数组：（基址寄存器和变址寄存器）
通过这两个寄存器，我们可以对主内存上特定的内存区域进行划分，从而实现类似于数组的操作。
比如：使用十六进制数将计算机内存上的一块地址划分出来。那么，凡是该范围的内存区域，只要一个32为的寄存器，就可以查看全部的内存地址。但是如果想像数组一样分割特定区域以达到连续查看的目的，使用两个寄存器会方便。比如，先把一个地址给基址寄存器，然后使用变址寄存器使这个值在一定的内存区域内变化。CPU会把基址寄存器+变址寄存器的值解释为实际查看的内存地址。变址寄存器的值就相当于高级编程语言程序中数组的索引功能。

实际地址=基址寄存器的值+变址寄存器的值
总的来说：基址寄存器的值用来固定，变址寄存器的值相当于数组索引的数值



事实上，CPU能够进行的处理非常的少，非常简单，机器语言的主要类型和功能如下：
类型								功能
数据转送指令	  寄存器的内存，内存的内存，寄存器的外围设备  之间的数据读写操作
运算指令 		  用累加寄存器进行算数运算，逻辑运算，比较运算和移位运算
跳转指令		  实现条件分支，循环和强制跳转
Call/return指令	  函数调用/返回调用前的地址

//外围设备常常指的是：链接到计算机的键盘，鼠标，显示器，设备装置，打印机等



XOR计算和NOT运算：
XOR运算只反转与1对应的位，NOT运算是反转所有的位

函数调用机制：
函数调用处理是通过把程序计数器的值设定成函数的存储地址来实现的
函数的调用需要在完成函数内部的处理后，处理流程再返回到函数调用点（函数指令的下一个地址）。如果只是转跳到函数的入口地址，流程处理就不知道返回到哪里了。

一般c语言编译后会变成很多行机器语言，所以地址大多是离散的。

字节是由bite（咬）引申出来的词语。

算数运算：十进制的加减乘除运算
逻辑运算：二进制的个数字位0和1的运算。逻辑非（NOT运算）、逻辑与（AND运算）、逻辑或（OR运算）、逻辑异或（XOR运算）。

真值表：各逻辑运算的结果列成的表

计算机运算小数时出错的原因：
由于计算机处理小数的机制，会导致计算机累加100个0.1是得不到10的
计算机运算出错的原因：
因为有一些十进制的数无法用二进制数来表示，就像计算机是无法使用二进制数来表示十进制数0.1的。事实上，十进制数0.1转换成二进制以后会变成0.00011001100…（1100循环）这样的循环小数


解决方法：浮点数
很多编程语言提供了两种小数处理方式：单精度浮点数类型（32位），双精度浮点数类型（64位）来表示全体小数。
浮点数是使用符号，尾数，基数，指数四部分来表示的小数。因为计算机使用的是二进制数，所以基数自然是2。所以在用浮点数表示小数的时候一般不会涉及到基数。
±m×n（的e次方）m表示的是尾数，n表示的是基数，e表示的是指数
对于双精度浮点运算，64位的时候，一般符号部分占用1位，指数部分占用11位，位数部分占用52位。
符号部分使用一个位，这个位位1的时候表示的是负数，这个位为0的时候表示正数或者0。
尾数部分：将小数点前面的值固定为1的正则表达式。尾部使用正则表达式可以将表现形式多样的浮点数统一为一种表达方式，这是为了方便计算机的处理。根据这个规则，0.75就是0.75×10的零次幂。也就是说只能使用尾数部分的0.75，指数部分是0这种方式来表示。根据这个方式来表达小数的方式就叫正则表达式。二进制就是将小数点前面的值固定为1的正则表达式。具体的来说，就是将二进制数的小数点左移或者右移数次以后，正数部分的第一位变成1，第二位之后全部变成0（这么做是为了消除第二位以上的数位）。而且，第一位的1在实际的数据中不保存。由于第一位必须是1，因此省略该部分后就节省了一个数据位，从而可以表示出更多的数据范围。
指数部分：EXCESS系统表现，使用这个的原因是为了表示负数的时候不使用符号位。在某些情况下，在指数部分需要使用负XXX次幂的形式来表示负数。通过将指数部分表示范围的中间值设为0，使得负数不需要使用符号位来表示。比如：当指数部分是8位单精度浮点数的时候，最大值11111111=255的1/2，即01111111=127（小数部分舍弃）表示的是0。

如何避免计算机运算出错：
计算机出错的原因之一是：采用浮点数来处理小数，也有位溢出而造成的计算错误。作为程序的数据类型，无论是单精度还是双精度都存在计算出错的可能。
解决的办法：
回避策略：无视这些错误，一般科学技术领域，这些很小的精度可以当作误差，本来就是近似值，无需为了这么一点点的误差担心
把小数当成正数来计算：计算机在处理小数的时候可能出现错误，但是计算机在处理正数的时候（只要不超过正数范围）就不会造成错误。所以，在计算小数的时候可以使用整数来代替小数，再把计算结果使用小数表示出来即可。比如原来需要把100个0.1相加，现在只需要把0.1乘以10倍，再相加一百次，最后把结果除以10即可。
除此之外，还有一种方法叫做BCD：BCD是一种使用二进制转换位十进制的方法，这个BCD是老式的大型计算机使用的，现在使用在不能出现丝毫错误的财务计算中。简单的来说，BCD就是使用4位二进制数来表示0到9中的一个数字

如何熟练的使用内存：
高级语言中的数据类型表示的是占据内存的大小和存储在该内存区域的数据类型
指针指的是用于存储内存地址的变量，所以在32位系统中，指针的大小是32位。



内存：
内存的物理机制：内存实际上是一种名位内存IC的电子元件。虽然内存IC包含DRAM、SRAM、ROM等多种形式，但是从外部看，内存IC中有电源、地址信号、数据信号、控制信号等用于输入输出的大量引脚（IC的引脚），通过为其指定地址来进行数据的读写。
ROM是一种只能用来读取的内存
RAM是一种可以被读取也可以被写入的内存。它分为需要经常刷新来保存数据的DRAM，不需要经常刷新电路就能够保存数据的SRAM
一般内存的引脚比如VCC,GND表示电源，A开头的是用于储存地址的引脚，D开头的是用于储存数据的引脚。
控制信号的引脚一般为：RD（读取）、WR（写入）

内存的逻辑模型是楼房：

数组是高效使用内存的基础：
数组是多个同样的数据类型的数据在内存中连续排列的形式。作为数组的元素会通过连续的编号被区分开来，这个编号成为索引。
指定索引后，就可以对该索引所对应的地址进行操作。索引和内存地址的变换是由编译器自动实现的。

栈，队列和环形缓冲区：
栈和队列可以不通过指定地址和索引来对数组的元素进行读写。
队列一般是以环状缓冲区的方式来实现的。换装存储区就是把数据给整个的首尾连接了起来。比如一个环形缓冲区容纳6字节的数据，当6个字节被读取满了的时候，读取的第7个字节会覆盖掉一开始输入的第一个字符。

链表使元素的追加和删除更加容易，通过使用二叉查找树，可以更加高效的对数组的元素进行检索。通过元素附带的上下的索引来实现链表。
二叉查找树是指在链表的基础上往数组追加元素时，考虑到数据的大小关系，将其分为左右两个方向的表现方式


内存和磁盘的亲密关系：
通过使用内存来提高磁盘访问速度的机制叫做磁盘缓存（disk cache）。
可以使用磁盘来作为虚拟内存运行一些程序，这样子就算一些计算机的内存不足以支撑起一个程序的运行，也能够很好的运行起来。
在windows系统里面，一般一个扇区的字节数是512字节。
从硬件的角度看，内存中数据的存储是用电流来实现的；磁盘中数据的存储是用磁效应来实现的。
内存相对于硬盘，就像硬盘相对于web网页一样，由于网页的连接速度有限，在网页上存在大文件的时候，web网页会把这些图片存储在相对快速的硬盘上。


虚拟内存把磁盘作为部分内存来使用：
虚拟内存是把磁盘的一部分作为假象内存来使用。
磁盘缓存是假想的磁盘，实际是内存；虚拟内存是假想的内存，实际是硬盘。
使用了虚拟内存，比如电脑有5M的内存，也可以运行10M的程序。但是，CPU只会去内存中调用数据，所以使用的时候虚拟内存（磁盘）与实际内存是要进行置换的。

虚拟内存有分页式和分段式两种，Windows采用的是分页式。这种方法是指在不考虑程序构造的情况下，把运行的程序按照一定大小的页进行分割，并且以页为单位在内存和磁盘之间进行置换。在分页内存中，通常把从内存输出到磁盘叫做page in，把磁盘的程序输出到内存叫做pageout。
分段式是把程序分割成以处理集合及数据集合等为单位的段落，然后再以分割后的段落为单位在内存和磁盘之间进行数据置换。

节约内存的编程方法：
以图形用户界面（GUI-graphical user interface）为基础的windows是一个巨大的操作系统。窗口和菜单都可以进行可视化操作的方式叫做图形用户界面。而MS-DOS操作系统，是由键盘输入命令来进行操作的CLI（命令行界面）。Windows的前身是MS-DOS操作系统，最初的版本可以在128Kb左右的内存上运行。但是想要Windows流畅运行的话，至少需要512Mb的运行内存。由于硬盘的速度远远小于内存的速度，所以虚拟内存的方法不能彻底解决内存不够的问题。

怎么把运行的应用文件变小：
通多DLL（dynamic link library）文件实现函数共有：
DLL文件是在程序运行时可以动态加载library（函数和数据集合）的文件。多个用用可以使用同一个DLL文件来达到节省内存的效果。

在EXE程序文件中，静态加载文件的方式是静态链接。在各个运行程序中内置静态链接，同时运行两个程序，内存就存在了具有同一函数的两个程序，但是这会导致内存的利用效率降低。如果函数是独立的DLL文件而不是应用的执行文件（EXE文件），由于一个DLL文件的内容在运行时被多个应用共有，因此内存中存在的函数的程序只有一个，这样内存的利用效率也变得高了。
Windows操作系统本身也有很多个DLL文件集，。利用多个DLL文件，一个好处是可以节约了一定的内存，另一个好处是在不变更EXE文件的情况下，只通过升级DLL文件就可以更新。

在c语言程序的编写中，使用_stdcall可以减小程序文件的大小：
_stdcall是standard call（标准调用）的略称，Windows提供的DLL文件大多都是_stdcall调用方式。这主要是为了节约内存，另一个方面，用c语言编写程序内的函数，默认设置都不是_stdcall。C语言特有的调用方式称为c调用，因为c语言对应的函数的传入参数是可变的（可以设定任意参数），只有函数调用才能知道有多少个参数，这种情况下，栈的清理作业就无法完成。不过在c语言中，如果函数的参数数量固定的话，指定_stdcall是没有任何问题的。
C语言中，在调用函数后，需要执行栈清理处理指令。栈清理处理是指把不需要的数据从接收和传递函数的参数时使用的内存上的栈区域中清理出去。这个命令不是程序记述的而是程序编译时由编译器自动附加到程序中的。编译器默认将处理附加在函数的调用方。在c语言中，函数的返回值是通过寄存器来返回的，不是通过栈来返回的。
注：CPU会提前准备好栈机制，在汇编语言中，往栈中存储数据使用的是push，在栈中取出数据使用的是pop指令。栈一般是用来实现函数的调用机制的，如果想任意使用栈，需要自己用程序来实现需要的栈机制。


磁盘的物理结构：
磁盘的物理结构指的是磁盘存储数据的形式。
磁盘通过把它的物理表面划分成多个空间来使用，划分的方式有扇区方式和可变长方式两种。
扇区方式：将磁盘划分为固定长度的空间
可变长方式：将磁盘划分为长度可变的空间

扇区方式中，把磁盘表面分成若干个同心圆的空间就是磁道，把磁道按照固定大小（能存储的数据长度相同）划分而成的空间就是扇区。

扇区是对磁盘进行读写的最小单位，windows中使用的扇区一般一个扇区是512个字节。Windows在逻辑方面（软件方面）对磁盘进行读写的单位是磁盘整数倍簇。
根据磁盘容量的不同，1簇可以是512字节（1簇=1扇区）、1Kb（1簇=2扇区），…，32Kb（1簇=64扇区）。磁盘的容量越大，簇的容量也就越大。不过在软盘中，簇的大小和扇区的大小是一样的，都是512字节。

不管是硬盘还是软盘，不同的文件是不能存储在一个簇中的，否则就会导致只有一方的文件不能被删除。因此，不管多么小的文件，都至少占用1簇的空间，所以所有的文件都会占用1簇的整数倍的空间。1簇中没有使用的区域会保持不被使用，这是机制规定的，无法认为改变。如果减少簇的容量，磁盘访问次数就会增加，会导致读写文件的时间变长。由于在磁盘表面上，表示扇区区分的领域是必要的，因此如果簇的容量过小，磁盘的整体容量也会减少。扇区和簇的大小，是由处理速度和存储容量平衡决定的。

亲自尝试压缩数据：
压缩文件的拓展名有LZH和ZIP等：LZH是LHA等工具压缩过的文件的拓展名，该压缩格式有时候也称为LZH格式。ZIP是用PKZIP等工具压缩过的文件的拓展名。该压缩格式有时候也称为ZIP格式。

文件以字节为单位保存，文件是将数据存储在磁盘等存储媒介中的一种形式，文件就是字节数据的集合。如果文件中存储的数据是文字，那么该文件就是文本文件；如果是图形，那么该文件就是图像文件。在任何情况下，文件中的字节数据都是连续存储的。

RLE算法的机制：
RLE算法是一种文件的压缩算法，例子：AAAAAABBBCCCCCC压缩后的样子是A6B3C6这样子，这样子就节省了很大一部分的空间。
像这样，把文件内容用  数据×重复次数 这样子的形式来表示的压缩方法称为RLE（run length encoding，行程长度编码）算法。它经常被用于压缩传真的图像，因为传真的图像是黑白的两种颜色，而且黑白两种颜色很多时候都是粘连在一起的，使用RLE算法可以节省下很大的一部分空间。

RLE算法的缺点：
针对相同数据经常连续出现的文件或者图片中，RLE算法可以发挥很好的效果，但是它并不适合文本文件的压缩。然而使用RLE算法对文本文件进行压缩的话，会导致压缩后的大小比文本文件的大小要大，所以RLE算法一般用于压缩图片文件和EXE文件。



通过莫尔斯编码来看哈夫曼算法的基础：
哈夫曼算法：多次出现的数据用小于8的位的字节数来表示，不常用的数据可以用超过8位的字节数来表示，哈夫曼算法不同于普通情况下1个字符占用一个字节的存储大小这一观念。但是特别注意的是：不管是没有满8位的数据还是超过8位的数据，最终都要以八位为单位保存在文件中。这还是因为磁盘是以字节为单位来保存数据的。但是为了实现这一个处理，压缩程序会比RLE算法程序复杂很多，不过作为回报，哈夫曼算法在文本文件中的压缩率也高很多。


为了更好的了解哈夫曼算法，需要先了解莫尔斯编码。莫尔斯编码不是通过语言，而是通过“滴答滴答”这些长点和短点的组合来传递文本信息的。（摩斯密码）

用二叉树实现哈夫曼编码：莫尔斯编码是根据日常文字中各字符出现频率来决定各字符的编码的数据长度的，在使用哈夫曼编码的时候，需要进行更改，把出现频率最高的字符使用最短的位来表示以提高压缩率。


制作哈夫曼树（制作顺序）：
步骤一：列出数据及其出现的频率，按照降序排列
步骤二：选出两个出现频率最小的数字，把这两个数字拉出两条线，并在交叉处写上这两个数字的和，当有多个选项的时候，任意选取即可。
步骤三：重复步骤二，可以连接任何位置的数值
步骤四：最后这些数字会被汇集到一个点上，该点就是根，这样哈夫曼树也就完成了。按照从根部到底部叶子的顺序，在左侧的树枝处写上0，在右边的树枝处写上1，然后从根部开始沿着树枝到达目标文字后，再按照顺序把通过的树枝上的0或者1写下来，就可以得到哈夫曼编码了。


使用哈夫曼树后，出现频率越高的数据所占用的数据位数就越少，而且根据数据的区分也可以很清晰的实现。从刚刚建立哈夫曼树的步骤来看，用枝条连接的时候我们是从出现次数比较少的数值开始的。枝条的数目越多，编码的位数也就越多。




可逆压缩和不可逆压缩：
Windows的标准图像数据形式是BMP（bitmap），是Windows自带的画笔来做成的一种图像数据形式，这个格式是完全未压缩的。因为显示器和打印机输出的bit（点）是可以直接映射（mapping）的，因此便有了BMP=bitmap这一个名称、
其他的图像格式：
JPEG（joint photographic experts group）是数码相机等常用的一种数据形式
TIFF（tag image file format）是一种通过在文件头中包含“标签”就能够把显示出数据性质的图像数据形式
GIF(graphics interchange format)是美国CompuServe开发的一种数据形式，这种格式要求格式不能超过256色。

非可逆压缩：JPEG格式：把构成图像的戴南镇颜色信息由RHB（红色，绿色，蓝色）形式转换成YcbCr（亮度，蓝色色度，红色色度）形式。一般来说，人眼对亮度比对颜色要敏感一些，JPEG格式的大小会小一些但是它是非可逆压缩。

而GIF格式的文件虽然是可逆压缩，但是它仅仅支持256色的限定，所以还原后会导致一些颜色的缺失，使文件变得模糊。

TITF文件格式竟然比BMP格式的图片还要大的原因是它没有压缩而且它还有标签。

压缩算法有很多很多种类，但是没有一个万能的算法。




程序是在何种环境中运行的：
Java虚拟机的作用是运行Java应用的字节代码，只要为各个系统安装专用的Java虚拟机，同样的字节代码就能在各种环境下运行了。
如果运行的环境不同，程序是不能通用的，举一个很普通的例子，在Windows里面使用的程序是不可以在Linux里面使用的。

运行环境=操作系统+硬件

AT兼容机：可以和IBM开发的PC/AT在硬件上相互兼容的计算机的总称。称为“PC/AT兼容机”和“DOS/V机”
Ps：IBM已经把计算机事业部卖给了联想

因为美国Intel微处理器是按照8086，80286，80386，80486，Pentium……这样的顺序不断升级的，因为这些型号后面都带有86，所以总称为x86，32位处理器也称为“IA-32”

CPU只能解释其自身固有的机器语言，不同的CPU能解释的机器语言的种类也是不同的。例如CPU有x86，MIPS,SPARC,PowerPC等类型，他们各自的机器语言是完全不同的。

计算机语言的程序称为本地代码
程序员使用c语言等编写程序，在编写阶段仅仅是文本文件，文本文件在任何文件下都能显示和编辑，称之为源代码。通过对源代码进行编译，就得到了本地代码。比如软件包CD-ROM中，收录的就不是源代码，而是本地代码，本地代码一般是EXE文件或者DLL文件等格式。

Windows克服了CPU以外的硬件差异：
Windows的前身操作系统MS-DOS（Microsoft disk operating system），内存和I/O地址的构成都是不同的，因此每个机型都有MS-DOS应用。X86提供专门用来同外围设备进行输入输出的I/O地址空间（I/O地址分配），至于各外围设备会分配到什么样的地址，主要由计算机的机型来决定，以前想要使用一个软件还是需要买各种适合各种机型的软件。这是因为应用软件的功能中，存在直接操作计算机硬件的部分。这个的原因是因为但是的MS-DOS功能尚且不完善，二是提高了程序的运行速度。所以说Windows很好的解决了这一个问题。

在Windows应用软件中，就按盘输入，显示器输出等并不是直接向硬件发送指令，而是通过Windows发送指令间接实现的。因此我们就不用注意内存和I/O地址的不同构成了，因为Windows操作系统操作的是硬件而非是应用软件。不过，Windows需要为不同的机型提供不同的版本。

不同操作系统的API的不同：
操作系统的种类：
比如：AY兼容机的情况下，除了Windows之外，还可以采用unix系列的Linux以及freeBSD等多个操作系统。
应用程序向操作系统传递指令的途径称为API（application programming interface），API也成为系统调用。Windows和unix系列操作系统的API，提供了任何应用程序都可以利用的函数组合。因为不同操作系统的API是有差异的，因此将同样的应用程序重新写到应用程序中利用到API的部分。比如键盘输入，鼠标输入，显示器输出，文件输入输出等同外围设备进行输入输出操作的功能，都是通过API提供的。

总之，程序（本地代码）是由操作系统和硬件共同决定的。

Unix系列的操作系统FreeBSD存在一种名为Ports的机制，该机制能够结合当前运行的硬件环境来编译应用的源代码，进而得到可以运行的本地代码系统。如果目标应用的代码没有在硬件上的话，Ports（porting移植的意思）就会使用FTP（File transfer protocol）（FTP是一种连接到互联网上计算机之间传送文件的协议）连接到相关站点来下载代码。所以它可以根据不同的操作环境来重新调整程序，一般也称为“移植”。

利用虚拟机获得其他操作系统环境：
虚拟机软件：不通过移植，可以使用别的方法来使用其他操作系统的应用。

提供相同运行环境的Java虚拟机：
除了虚拟机的方法之外，还有一种方法能够提供不依赖于特定硬件及操作系统的程序运行环境，就是Java
Java有两层意思：一个是作为编程语言的Java，另一个是作为程序运行环境的Java
Java也是将Java语法记述的源代码编译后运行，不过，编译后生成的并不是特定CPU使用的本地代码，而是名为字节代码的程序。字节代码运行的环境就成为Java虚拟机（Java virtual machine）
Java虚拟机时一边把Java字节代码逐一转换成本地代码一边运行的。
注：PDA（personal digital assistant）是指可以放入手提包中的小型手持计算机，也成为手持设备。
从操作系统来看，Java虚拟机是一个应用，而从Java应用的方面来看，Java虚拟机就是运行环境。但是在使用Java虚拟机的时候，让所有字节代码在任意Java虚拟机上运行有一些困难，而且当我们使用只适用于某些特定硬件的功能的时候，就会出现在其他Java虚拟机上无法运行或者功能受限的情况。
另一个方面就是运行速度的问题，Java虚拟机每一次都需要把字节代码变换成本机代码，这一机制是造成运行速度慢的原因。

BIOS和引导：
程序的运行环境中，存在着名为BIOS（basic input/output system）的系统。BIOS存储在ROM中，是预先内置在计算机主机内部的程序。BIOS除了键盘，磁盘，显卡等基本控制程序外，还有启动“引导程序”的功能。
引导程序是存储在启动驱动器其实区域的小程序。操作系统的启动驱动器一般是硬盘，不过有时候也可以是CD-ROM或者软盘

开机后，BIOS会确认硬件是否正常运行，没有问题的话就会启动引导程序。引导程序的功能是把在硬盘等记录的OS加载到内存中运行。虽然启动应用是OS的功能，但OS并不能自己启动自己，而是通过引导程序来启动。

Bootstrap原本的意思是靴子上部的拔靴带，BIOS（拔靴带）这样小的程序可以带动（启动）操作系统这样的大程序（靴子），所以由此得名。


从源文件到可执行文件：
将多个目标文件结合生成EXE文件的工具称为链接器，通过编译和链接得到EXE文件，通过编译源代码得到本地代码。
拓展名为.obj的目标文件（object）的内容是本地代码
把多个文件收录到一起的文件叫做库文件，链接器会从库文件中抽出必要的目标文件并将其结合到EXE文件中。还存在一种程序运行时结合的DLL形式的库文件。
在程序运行的时候，用来动态申请分配的数据和对象的内存区域的形式称为堆，堆的内存空间会根据程序的命令进行申请及释放。
Dump的意思：指把每个字节用2位16进制的数来表示的方式。
本地代码就是各种数值的罗列，每一个数值都表示某一个命令或数据

编译器：能够把c语言等高级语言转换陈本地代码的程序就叫做编译器。编译器里面有一个源代码和本地代码的对应表，除此之外，读入的源代码要经过语法解析、句法解析、语义解析等，才能生成本地代码。

仅仅依靠编译是无法得到可执行文件的，编译器转换源代码后，就会生成本地文件，但是本地文件是无法直接运行的。为了得到可以运行的EXE文件，编译之后还需要进行“链接”处理

把多个目标文件结合，生成一个EXE文件的处理就是链接，运行连接的程序就称为连接器

启动及库文件：
目标文件记述的是同所有程序起始位置相结合的处理内容，称为程序的启动。因此即使函数不调用其他目标文件的函数，也必须要进行链接，并且和启动链接起来。

库文件指的是把多个目标文件集成保存到一个文件中的形式。链接器指定库文件后，就会从中把需要的目标文件抽取出来，并同其他目标文件结合生成EXE文件。

外部符号是指其他目标文件中的变量或函数
标准函数：不是通过源代码形式而是通过库文件形式和编译器一起提供的函数


DLL文件及导入库：
Windows以函数的形式为应用提供了各种功能，这种形式的函数称为API（application programming interface，应用程序接口）
Windows中，API的目标文件，并不是存储通常的库文件中，而是存储在名为DLL（dynamic link library）文件的特殊库文件中。DLL文件是程序运行时动态结合的文件。
导入库：一是有函数在这个DLL文件中，另一个是存储着DLL文件的文件夹信息，函数的目标文件的实体实际上并不存在，这样的库文件称为导入库。

静态链接库：与导入库相反，存储着目标文件的实体，并直接和EXE文件结合的库文件形式称为静态链接库（static）。

注：其实这边特别要注意的是目标文件（.obj）和可执行文件（.exe）之间的差别。
从程序员编写的源文件编译后编程目标文件，存储在一个文件夹中以后生成了一个启动用的目标文件。之后从静态链接库里面抽出变成一个带有了函数功能的目标文件，再从导出库里面抽出用来调用函数的信息，最后进行静态链接生成可执行文件。之后从动态链接库里面抽出函数的目标文件再动态链接到可执行文件EXE上。


可执行文件运行的必要条件：
EXE文件是作为单独的文件储存在硬盘中的。通过资源管理器找到并且双击EXE文件，就会把EXE文件的内容加载到内存中运行。

在运行EXE文件的时候，内存地址是随机分配的，每次运行同一个EXE文件分配到的内存地址是不一样的。在程序运行时，虚拟的内存地址会转换成实际的内存地址。链接器会在EXE文件的开头追加转换内存地址所需的必要信息，这个信息称为再配置信息。EXE文件的在配置信息，就成了变量和函数的相对地址。相对地址表示的是相对于基点地址的偏移量，也就是相对距离。在源代码中，虽然虽然变量和函数是在不同位置分散记述的，但在链接后的EXE文件中，变量和函数会变成一个连续排列的组。这样，各变量的内存地址也就可以用相对于函数起始组起始位置这一基点的偏移量来表示。而各组基点的内存地址是在程序运行的时候被分配的。


程序加载的时候会生成栈和堆：
EXE文件的内容分为再配置信息、变量组和函数组，不过当程序加载到内存后，除此之外还会生成两个组，那就是堆和栈。栈是用来存储函数内部临时使用的变量（局部变量，局部变量是指只在调用函数的时候存在于内存中的变量。全局变量是指程序运行的时候一直存在于内存中的变量。），以及函数调用时所用参数的内存区域。堆：堆是用来存储程序运行的时候的任意数据以及对象的内存区域。

EXE文件中并不存在栈及堆的组，栈和堆需要的内存空间是在EXE文件加载到内存后开始运行时得到分配的。因此内存中的程序，就是由用于变量的内存空间、用于函数的内存空间、用于栈的内存空间、用于堆的内存空间这4各部分构成的。但是在内存中加载Windows等操作系统的内存空间是另外一回事了。

栈和堆的相似之处在于他们的内存空间都是在程序运行的时候得到申请分配的（不管是什么程序，程序的内容都是由处理和数据构成的。大多数编程语言都是用函数来表示处理、用变量来表示数据）（栈和堆的大小，可以由程序员任意指定。在高级编程语言中，编译器会自动生成指定栈和堆大小的代码，并将其附加到程序中）。栈中对数据进行存储和舍弃（清理处理）的代码，是由编译器自动生成的，不需要程序员的参与。使用栈的数据的内存空间，每当函数被调用是时都会得到申请分配，并在函数处理完毕后自动释放。
堆的内存空间，则要根据程序员编写的程序，来明确进行申请分配或释放。

根据编程语言的不同，对于内存空间申请分配和释放的车光绪的编写方法是多种多样的。比如c语言中通过malloc（）函数来进行申请分配，通过free（）函数来释放，而c++中则是通过new运算符来进行申请分配，通过delete运算符来释放的。但是，无论c语言还是c++语言，如果没有在程序中明确释放堆的内存空间，那么即使在处理完毕之后，该内存空间仍然会有一直残余。这个现象称为内存泄漏（memory leak），它是一个bug（程序的错误）。如果内存泄漏一直存在的话，就有可能造成内存不足。也可以这么想，一个水龙头一个晚上一直在滴水，终于把在下面的一个大水桶给滴满并且溢出了。





编译器和解释器有什么不同：
编译器是在运行前对源代码进行解释处理的，而解释器则是在运行时对源代码的内容一行一行地进行解释处理的。

“分割编译”指的是什么：
将整个程序分成多个源文件来编写，然后分别进行编译，最后链接成一个EEXE文件。这样每个源代码都相对的变得短，便于程序的管理。

“Build”指的是什么：
根据开发工具种类的不同，有的编译器可以通过选择“Build”菜单来生成EXE文件。这种情况下，Build指的是连续执行编译和链接。

使用DLL文件的好处是什么：
DLL文件中的函数可以被多个程序公用，因此借助该功能可以节省内存和磁盘空间。此外，在对多个函数的内容进行修正的时候，还不需要重新链接（静态链接）使用这个函数的程序。

不链接导入库的话就无法调用DLL文件中的函数吗：
通过使用LoadLibrary（）及GetProcAddress（）这些API，即使不链接导入库，也可以在程序运行时调用DLL文件中的函数。不过使用导入库更简单一点。

“叠加链接”这个属于指的是什么：
将不会同时执行的函数，交替加载到同一个地址中运行。通过使用“叠加链接器”这一特殊链接器即可实现。在计算机中配置的内存容量不多的MS-DOS时代，经常使用叠加链接。

和内存管理相关的“垃圾回收机制”指的是什么：
垃圾回收机制（garbage collection）指的是对处理完毕后不再需要的堆内存空间的数据和对象（这里提到的对象不是对象文件，而是面向对象编程语言中的对象）进行清理，释放他们所使用的内存空间，这里把不需要的数据比作垃圾。在进行该处理的时候，c语言使用的是free（）函数，c++使用的是delete运算符。在c++基础上开发出来的Java及c#这些编程语言中，程序运行环境会自动进行垃圾回收，这样子可以避免由于程序员的疏忽（忘记记述内存的释放管理）而造成的内存泄漏了。





操作系统和应用的关系：
监控程序的主要功能是程序的加载和运行，监控系统也可以说是操作系统的原型。
类似于microsoft word之类的提高特定处理效率的程序称为“应用”，而应用的环境就是操作系统。在计算机尚不存在操作系统的年代，完全没有任何程序，因此程序员需要编写出处理相关的所有程序。用机器语言编写程序，然后再使用开关将程序输入。这种过程非常麻烦，于是有人开发出了仅具有加载和运行功能的监控程序，这就是操作系统的原型。通过实现启动监控程序，程序员就可以根据需要将各种程序加载到内存中运行。
注：监控程序的功能：1、加载程序  2、运行程序
人们在利用监控程序编写程序的过程中，发现了很多程序有共通的部分，比如键盘输入文字数据等处理在任何程序下面都是一样的。因此，基本的输入输出部分的程序就被追加到了监控程序中，初期的操作系统就这样诞生了。
操作系统并不是单独的程序，而是多个程序的集合体。
注：基本的输入输出程序的功能：1、通过键盘输入  2、输出到显示器等
初期的操作系统=监控程序+基本的输入输出程序

要意识到操作系统的存在：因为制作软件的程序员不用再制造直接控制硬件的程序了，慢慢的都走上了制作通过操作系统控制硬件的道路。但是程序员还是需要深度学习硬件知识的，由于程序员不再需要考虑硬件的问题，所以程序员的数量增加了。但是要成为一个好的程序员，需要对硬件知识有深入的了解。掌握基本的硬件知识，并且借助操作系统进行抽象化，可以大大提高编程效率。
在c语言中，time（）函数是用来获取当时的日期和时间的。
例：time_t tm;//保存当前日期和时间的变量，为time_t类型的变量申请分配内存空间
time(&tm);//取得当前的日期和时间，将当前的日期和时间数据保存到变量的内存空间中
printf（“%s\n”,ctime(&tm)）;//在显示器上显示日期和时间的内容

应用的可执行文件指的是计算机的CPU可以直接解释并运行的本地代码，不过这些代码无法直接控制计算机中配置的时钟IC以及显示器用的I/O等硬件
操作系统收到应用发出的指令进行解释，然后会对时钟IC（实时时钟）（保存日期和时间的实时时钟）和显示器用的I/O进行控制。


系统调用和高级编程语言的一致性：
操作系统的硬件控制功能通常是通过一些小的函数集合体的形式来提供的。这些函数及调用函数的行为统称为系统调用，也就是应用对操作系统的功能进行调用的意思。
移植性指的是同样的程序在不同的操作系统运行下需要花费的时间等，花费的时间越少表示移植性越好。
在高级语言中存在的能够直接系统调用的编程语言，用这种方式做成的应用，移植性差。


操作系统和高级编程语言使硬件抽象化：
在c语言中，fopen（）--file open；fputs（）--file put string；fileclose（）--file close这些函数都是通过操作系统对硬件进行的操作。在物理上的磁盘媒体扇区被抽象成了文件。
MS-DOS系统使用的使16位操作系统。










